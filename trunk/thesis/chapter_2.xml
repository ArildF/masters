<?xml version="1.0" encoding="utf-8"?>
<chapter id="chapter_2">
  <title>Garbage collection in the CLR</title>
  <sect1 id="chapter_2-sect-1">
    <para>The ECMA standard that defines the Common Language Runtime is 
    remarkably silent on the subject of garbage collection. Volume 1, 
    Architecture<xref linkend="ecma-vol-1"/> only mentions the term
    <quote>garbage collection</quote> once, and even then very briefly.
    The detailed specification<xref linkend="ecma-bcl-detailed"/> of 
    the <firstterm>Base Class Library </firstterm> does however contain the 
    following note:</para>
    
    <blockquote>The garbage collector is responsible for tracking and reclaiming
    objects allocated in managed memory. Periodically, the garbage collector
    performs a garbage collection to reclaim memory allocated to objects for
    which there are no valid references. Garbage collections happen
    automatically when a request for memory cannot be satisfied using available
    free memory. A garbage collection consists of the following steps: During a
    collection, the garbage collector will not free an object if it finds one
    or more references to the object in managed code. However, the garbage
    collector does not recognize references to an object from unmanaged code,
    and may free objects that are being used exclusively in unmanaged code
    unless explicitly prevented from doing so. </blockquote>
    
    <para>Even so, the lack of a detailed specification of the memory 
    management model in the main specification implies a considerable flexibility 
    in how a CLR-conforming implementation manages memory. However,
    all the existing implementations of the CLR<footnote><para>At the time of
    writing, these include Microsoft .NET, Mono<xref linkend="mono"/>, 
    Portable .NET<xref linkend="portabledotnet"/> and the Shared Source 
    CLI<xref linkend="sscli"/>.</para></footnote> use a tracing garbage 
    collector, as described in the previous chapter.</para>
  </sect1>
  
  <sect1 id="chapter_2-sect-2">
    <title>Finalization</title>
    <para>A large number of .NET classes hold onto resources beyond the actual 
    memory they occupy in the managed heap. For example, the .NET 
    <type>System.IO.FileStream</type> class owns an operating system file 
    handle. Likewise, the <type>System.Windows.Forms.Control</type> class
    (with descendants) holds onto a window handle (a <type>HWND</type>).
    The <type>System.Drawing.Brush</type> class keeps a reference to a Windows
    brush object (a <type>HBRUSH</type>).</para>
    
    <para>These resources are not available in infinite supply. The operating 
    system has a limited number of them, and it is important that code that
    acquires such a resource also releases it in a timely fashion.</para>    
    
    <sect2 id="chapter_2-sect-2-1">
      <title><function>Finalize()</function></title>
      <para>To ensure these kinds of resources can be released, the CLR 
      <type>Object</type> type declares a virtual method called 
      <function>Finalize()</function>. Types can override this method and 
      use it to release whatever unmanaged resources they are holding on to.
      The garbage collector will call this method before the object is finally 
      destroyed and its memory released back to the managed heap. A typical 
      Finalize() implementation might look like this:</para>
      
      <programlisting><![CDATA[

public class Brush
{
   public Brush()
   {
      this.handle = Win32.CreateBrush();
   }   
   
   protected override void Finalize()
   {
      Win32.CloseHandle( this.handle );
   }
   
   // implementation omitted
   
   private IntPtr handle;
}      
      ]]>      
      </programlisting>
      
      <para>In C# and C++, two of the languages that run on the CLR, the 
      <function>Finalize()</function> method is declared using the same syntax
      as C++ destructors. The finalizer from the above example could then look
      like this:</para>
      
      <programlisting><![CDATA[
    ~Brush()
    {
      Win32.CloseHandle( this.handle );
    }      
      ]]>
      </programlisting>
    </sect2>
    
    <sect2 id="chapter_2-sect-2-2">
      <title>The finalizer queue</title>
      <para>When a GC heap is collected, objects that have a finalizer are
      <emphasis>not</emphasis> collected right away. Instead they are put in a
      special data structure called the <firstterm>finalizer queue</firstterm>. 
      A background thread, the <firstterm>finalizer thread</firstterm>, starts
      up and visits all the objects in the queue, invoking their 
      <function>Finalize</function> methods. If the act of finalizing them 
      doesn't revive them (make them accessible again from some other object),
      they are again marked for garbage collection and picked up by the 
      collector on its next run.</para>
      
      <para>The behavior just described causes objects with a finalizer to 
      have a longer life than objects without one. If you have a large number
      of finalizable objects in your system, performance will obviously 
      suffer, since these objects will have a much longer lifespan; i.e. 
      they will always survive at least one garbage collection. The external
      resources these objects hold on to will also be held for a longer time
      than necessary, since the finalizer won't necessarily be run instantly
      after the object has been collected.      
      </para>
      
      <para>One other thing about finalization is that there is no 100%
      guarantee that it will happen. In some cases, the program might
      exit without having run all of its finalizers. When a program is exitting,
      the runtime gives a certain amount of time for remaining finalizers to 
      run. When the time runs out, the finalizer thread is killed off and the
      runtime (and the program with it) is shut down anyway). There is only a
      single finalizer thread, so any one of the finalizers could prevent the
      remaining ones from running by taking too long to execute. </para>      
    </sect2>
    
    <sect2 id="chapter_2-sect-2-3">
      <title>The IDisposable pattern</title>      
      <para>As the previous section describes, relying on the finalizer to 
      take care of your external resources has some drawbacks: it is 
      non-deterministic in that you never know when (or even if) it will run, 
      and it causes objects to linger and hold onto memory for a longer time
      than necessary. To support a more deterministic way of releasing said
      resources, the designers of the .NET framework provided the 
      <firstterm>IDisposable pattern.</firstterm></para>
      
      <para><type>System.IDisposable</type> is an interface defining a single
      method, <function>Dispose()</function>:</para>
      <programlisting><![CDATA[
namespace System
{
  public interface IDisposable
  {
    void Dispose();
  }
}]]></programlisting>
      <para>Types that own unmanaged resources will implement this interface.
      The user of such a type can then call <function>Dispose()</function> 
      explicitly when he is done with the object, causing the resource to be
      freed instantaneously. For types where another name for this method would
      be more semantically correct, one can provide another method with the
      appropriate name and have it call <function>Dispose()</function> (or the 
      other way around). For example, the <type>FileStream</type> class 
      implements <type>IDisposable</type>, but provides a <function>Close()
      </function> method intended for the consumer to use.</para>
      
      <para>A strategy of implementing <emphasis>only </emphasis>
      <type>IDisposable</type> can be a bit dangerous, though. You have no 
      guarantees that the user will ever bother calling 
      <function>Dispose() </function>, even if you write it in bold red type in
      the documentation (programmers can't read, and even if they could, they 
      wouldn't want to). Most such types will therefore also implement a 
      finalizer, in case the <function>Dispose()</function> method is 
      never called.</para>
      
      <para>Obviously, having 
      <emphasis>both</emphasis> <function>Dispose()</function> and 
      <function>Close()</function> being called would be 
      pretty wasteful. Yes, you would dispose of the unmanaged resource, but
      the problem of having finalizable objects linger for a much longer time
      than necessary would remain. Fortunately, you can tell the garbage 
      collector <emphasis>not</emphasis> to finalize a specific object if it's
      already been disposed. The most common implementation of <type>
      IDisposable</type> will call the <function>GC.SuppressFinalize()
      </function> method once it has disposed of the unmanaged resource: 
      </para>
      
      <programlisting><![CDATA[ 
public class Foo : IDisposable
{
    public Foo()
    {
        this.resource = CreateResource();              
    }
    
    ~Foo()
    {
        DoDispose();
    }
    
    public void Dispose()
    {
       DoDispose();
       GC.SuppressFinalize( this );
    }
    
    protected virtual void DoDispose()
    {
        FreeResource( this.resource );
    }
    
    // ...
    // implementation omitted
    // ...
      
      
    [DllImport( "os.dll")]
    private extern IntPtr CreateResource();
      
    [DllImport( "os.dll")]
    private extern void FreeResource( IntPtr resource );
   
   private IntPtr resource;  
   
}      
      
      ]]>
      </programlisting>
      
      <para>One could then use this object like this:</para>
      <programlisting><![CDATA[

Foo foo;
try
{
    foo = new Foo();
    
    // use foo here
}
finally
{
    foo.Dispose();
}
]]></programlisting>
      <para>Putting the <function>Dispose()</function> call in a finally 
      ensures that the object will be cleaned up even if the code in the try 
      block throws an exception.</para>
      
      <para>The <function>using</function> construct in C# makes the 
      IDisposable pattern even easier to use. The following C# code is 
      equivalent to the above example:</para>
<programlisting><![CDATA[
using( Foo foo = new Foo() )
{
    // use foo here
}
]]>  </programlisting>   
      
      
      
    </sect2>
  </sect1>
  
 
</chapter>

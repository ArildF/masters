<?xml version="1.0" encoding="utf-8" ?>
<!--<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN" 
    "file:///t:/docbook-dtd/docbookx.dtd">-->
<!--  
    vim:et ts=4 tw=78
-->
<article>
    <artheader>
        <title>Generics in C#</title>
        <author>
            <firstname>Arild</firstname>
            <surname>Fines</surname>
        </author>
    </artheader>
    <abstract>
        <para>
            This essay will discuss a new mechanism that will be introduced in
            version 2.0 of the <firstterm>Common Language
            Runtime</firstterm> (CLR), known as <firstterm>generics</firstterm>.
            We will take a look at how generics will be used when programming in
            various programming languages targeting the CLR, with an emphasis
            on the <firstterm>C# programming language</firstterm>. We will
            review how the CLR implements generics, and compare the
            implementation of generics in .NET with the way the Java Virtual 
            Machine performs the same task.
        </para>
    </abstract>
    <sect1>
        <title>What is the Common Language Runtime?</title>
        <para>The Common Language Runtime (CLR) is the central component of
        Microsoft's new development initiative <firstterm>.NET</firstterm>. It
        encompasses a runtime environment with rich support for a variety of
        modern object-oriented programming languages, allowing them to
        interoperate on a binary level. Components written in one language can
        be consumed directly by components written in another language as long
        as they both target the <firstterm>Common Language Subset(CLS)</firstterm>.
        The CLS represents a subset of the features of the CLR.
        In .NET parlance, a <firstterm>CLS consumer</firstterm> is a language
        that can utilize all the functionality in the CLS. Similarly, a 
        <firstterm>CLS producer</firstterm> is a language that can produce
        code consumable by .NET consumers. Most .NET languages are both
        CLS consumers and producers.</para>

        <para>Accompanying the first release of .NET was a new programming
        language, C#, which takes full advantage of the features available in
        the CLR.</para>
        
        <para>The .NET initiative in general was intended to replace Microsoft's
        component technology known as COM/DCOM as the premier choice for
        enterprise development on the Microsoft Windows platform, and has been
        marketed aggressively to compete against Sun Microsystem's Java
        programming language and the J2EE architecture.</para>

        <para>Microsoft's flagship development environment <firstterm>Visual
        Studio</firstterm> has a broad range of support for programming against
        the CLR. The current version of Visual Studio, Visual Studio 2003, lets
        developers target the CLR using 4 different languages: C++, Visual
        Basic, C# and Visual J#. It also allows third party compiler writers to
        integrate their compilers into the environment through the <firstterm>
        Visual Studio Industry Partner Program</firstterm><xref linkend="vsip"/>. 
        This program used to have a pretty hefty license fee(USD 10,000),
        but is now available to anyone for free.</para>

        <para>The CLI has been standardized through the <firstterm>European Computer
        Manufacturers Association</firstterm> (ECMA) and the <firstterm>International
        Standards Organization</firstterm> (ISO) under the designations 
        ECMA-335<xref linkend="ecma335"/> and
        ISO/IEC 23271<xref linkend="iso23271"/>, respectively.</para>
        
        <sect2>
        <title>The CLR's type system</title>
       <para> The CLR's type system reflects the fact that it is targetted
        primarily (but not exclusively) towards object-oriented languages. It
        supports two main categories of types:</para>
        <variablelist>
            <varlistentry><term>objects</term>
                <listitem>Object types are always allocated on the heap. Any
                representation of an object as a local variable merely consists
                of a pointer to the object. In addition to the instance data, 
                an object also contains a pointer to a 
                <firstterm>method table</firstterm>(used for dispatching virtual
                methods) and a <firstterm>sync block.</firstterm>The latter is 
                used for thread synchronization, for example with the C# keyword
                <token>lock</token>. These two pointers give each allocated 
                heap object an overhead of 8 bytes(on a 32 bit platform).
                </listitem>
            </varlistentry>
            <varlistentry><term>value types</term>
                <listitem>Value types are essentially nothing more than a
                sequence of bytes, and are represented as such on a program's
                stack. They are allocated either on the runtime
                stack or inline in objects that contain them. They support
                methods, but not inheritance, although they can implement 
                interfaces. Since the inheritance hierarchy is never more than one
                level deep, all method calls can be resolved at compile time and there
                is no need for a method table. Additionally, they do not have a 
                sync block, and cannot be used for thread synchronization(Technically,
                the compiler allows it, but you will merely end up boxing the value
                type into a freshly allocated anonymous object, which is completely
                useless). All primitive types, such as integers and
                floats, are represented in the CLR type system as value
                types. C#, for example, allows you to write this: 
                <programlisting>string s = 42.ToString();</programlisting></listitem>
            </varlistentry>
        </variablelist>

        <para>The inherent impedance between these two categories is one of the
        things that make a mechanism like generics desirable.</para>

        <para>The CLR also has support for a wide variety of other useful types,
        such as pointers, arrays and <firstterm>delegates</firstterm> (type safe
        function pointers), but they are implemented in terms of one of the
        above types.</para>
        
        <para>In the CLR, the <type>Object</type> type serves as the root of its
        single inheritance class hierarchy. Classes are not allowed to have more
        than one superclass, but they can implement any number of
        interfaces.</para>
        
        <sect3>
            <title>Boxing</title>
            <para>Essentially, boxing is a mechanism that allows you to store
            value types on the heap as a regular object. As the reader may
            remember, value types as local variables or member variables are
            stored merely as the sequence of bytes which they represent,
            instead of as a pointer to a heap object as with reference types.</para>
            
            <para>In order to store a value type in a container class that holds
            only <type>Object</type>s, you therefore need to copy it to a heap
            object so you can pass that heap object's reference to the container's
            <function>Add()</function> method.</para>
            
            <para>When the value type is retrieved from the container, the reverse
            operation, called <firstterm>unboxing</firstterm>, is needed. This 
            extracts the bytes for the value type and recreates it on the stack
            as a local variable.</para>
            
            <para>While boxing and unboxing are conceptually very elegant ways
            of solving the heap object/value type impedance problem, there is 
            little question that there is a performance cost inherent in it.
            </para>
        </sect3>
        
        <!-- structs/valuetypes vs heap objects -->
        <!-- delegates -->

        <sect3>
            <title>The Common Type System(CTS)</title>
            <para>The <firstterm>Common Type System</firstterm> is a specification
            which represents the minimum of types a language targeting the CLR
            should be able to consume and produce. It is a subset of the full
            type system. Partition II<xref linkend="ecma335"/> of the ECMA
            standard describes the CTS.</para>

            </sect3>
        </sect2>
        
        <sect2> <title>Common Intermediate Language(CIL)</title>
        <para>The <firstterm>Common Intermediate Language</firstterm>(CIL) is
        the language output by a compiler targetting the CLR. The language
        consists of a series of instructions manipulating a virtual stack based
        machine. However, this stack machine is intended to be purely
        hypothetical - CIL is designed to be compiled to native machine code
        before it is executed. This in contrast to the bytecodes of the JVM,
        which were originally designed to be executed directly by such a stack
        machine, implemented on top of the real hardware(although any modern
        JVM will now perform JIT-compilation as well).</para>

        <para>CIL is described in Partition III<xref
        linkend="ecma335"/> of the ECMA standard. </para>
        
        <para>The term MSIL(Microsoft
        Intermediate Language) describes Microsoft's implementation of CIL. This
        abbreviation is often used interchangeably with CIL and/or
        IL.</para> 
        </sect2>
        
    </sect1>
    <sect1>
        <title>What are generics?</title>
        <para>Wikipedia defines<xref linkend="wikipgen"/> generics as
        <quote>a technique that allows one value to take different datatypes
        (so-called polymorphism) as long as certain contracts such as subtypes
        and signature are kept.</quote> It further defines <firstterm>generic
        programming</firstterm> as <quote>the programming style emphasizing use
        of this technique.</quote></para>
        
        <para>This is a rather abstract definition, but the concept of generics 
        eventually boils down to the ability to parameterize a custom datatype
        on one or more types. The canonical example of a parameterized type is
        a collection class that can be parameterized on the types it holds. A
        generics mechanism is generally only applicable for statically typed
        languages - dynamically typed languages have little need for it. For
        example, a <type>List</type> class can be configured to hold either 
        integers or<type>Foo</type> objects, but not at the same time. With
        .NET generics in C#, the use of such a class would look like this:</para>
        <programlisting>
        <![CDATA[        
List<Foo> list = new List<Foo>();
list.Add( new Foo(42) );
list.Add( new Foo(84) );

Foo foo = list[0]; // get the first item in the list
        ]]>        
        </programlisting>
        <para>Since this list is parameterized on the <type>Foo</type>, any
        attempt to insert objects of another type would generate a compile-time
        error:</para>
        <programlisting>
        <![CDATA[
        
list.Add( 42 ); // ERROR: int is not a Foo
list.Add( new Bar() ); // ERROR: Bar is not a Foo

        ]]>        
        
        </programlisting>
        
        <para>Of course, normal polymorphic substitutability rules apply. If,
        in the above example, <type>Bar</type> was a class deriving from
        <type>Foo</type>, the insertion would be allowed by the compiler.</para>
        
        <sect2>
           <title>What exactly is <quote>polymorphism</quote>, and what does it
            have to do with generics?</title> 
            
            <para>The term polymorphism
            derives from the Greek words <quote>poly</quote>, meaning
            <quote>many</quote>, and <quote>morphos</quote>, meaning <quote>
            shape.</quote><footnote><para>Similarly, the word
            <quote>politics</quote> derives from <quote>poly</quote>, meaning 
            <quote>many</quote> and the word <quote>ticks</quote>, meaning
            <quote>nasty little bugs.</quote>.</para> </footnote> 
            
            In other words, it describes an entity that can take
            on many shapes. The most common application of the term in computer
            science is to describe the way most object oriented programming
            languages dispatch method calls on a type. However, it applies
            equally well to <quote>function overloading</quote> (several
            functions having the same name, but different argument lists) and
            <quote>generics</quote>. In generics, the generic type takes on a
            different 'shape' for each different type it is parameterized on.
            </para>
        </sect2>
        
        <!-- C# programmers coming from C++ - miss templates -->
        <!-- define "polymorphism" -->
        <!-- parametric polymorphism vs dynamic/virtual approaches 
        advantages of pp -->
        <!-- other languages supporting 'generics'(in a broad sense) -->

        <sect2>
        <title>The motivation for generics in .NET</title>
        In versions of the CLR prior to (the not yet released) 2.0, developers
        have had certain options when it came to storing their custom types in 
        containers:
        <variablelist>
            <varlistentry>
                <term>Use the standard object-based containers.</term>
                <listitem><para>The .NET Framework Base Class Library (BCL)
                ships with an adequate set of container classes, all storing
                items of type <type>Object</type>. Using these containers for
                value types had certain performance implications since it
                incurred the cost of boxing. It also relinquished compile-time
                type safety, since the compiler had no way of checking that
                only objects of one type were inserted into the container.
                Additionally, retrieving objects from the container required a
                cast operation. This cast was not entirely free, since the
                compiler had to insert code to do a runtime type check and
                potentially cast an exception if the real object type
                didn't match the type cast to.</para></listitem>
            </varlistentry>
            
            <varlistentry>
                <term>Write custom containers from scratch.</term>
                <listitem><para>You could, of course, always write your
                IntegerList class from scratch. This would avoid the boxing
                problem associated with the use of the standard containers and
                value types(described above), and there would be no need for a
                cast when retrieving an object from the list.</para>
                
                <para>The obvious downside is of course that writing such
                custom containers is extremely dull gruntwork that incurs
                development and maintenance costs. Additionally, you would
                rarely need only a single specialized container, leading to the
                explosion of <type>IntegerList</type>, <type>FloatList</type>
                and <type>FooList</type> objects all over the place. If you
                wanted to change the algorithm used or the interface of these
                classes, you needed to ensure that the changes were made in all
                of them.</para>
                </listitem>                
            </varlistentry>
            <varlistentry>
                <term>Use a code generator.</term>
                <listitem><para>Of course, since writing a custom container
                from scratch is <quote>extremely dull gruntwork</quote>, it is
                a perfect candidate for automation by a computer. There are
                several tools out there that take as input the types the
                container should store, and spits out a perfect custom
                container that requires no casting or boxing, even for primitives.
                </para></listitem>
            </varlistentry>
        </variablelist>
        <!-- use explicit interface implementation, derive from CollectionBase, use ArrayList-->
        <!-- boxing, unboxing -->
        <!-- code generation -->
        <!-- examples -->
        </sect2>
        
       
    </sect1>
    <sect1>
        <title>.NET generics</title>
        <para>A preliminary specification for version 2.0 of the C# programming
        language was released in October 2003. It contained, as everyone had
        expected, a proposal for a generics mechanism, in addition to other new
        features as <firstterm>anonymous methods</firstterm>,
        <firstterm>iterators</firstterm> and <firstterm>partial types.</firstterm>
        While the other three features are exciting in their own right, they will 
        not be discussed any further here.
        </para>
        
        <para>Comments made by Microsoft employees involved with the language
        design on C# and .NET newsgroups and blogs indicated that generics
        was a feature they had wished to include in the very first release of C#,
        but that time did not permit it. Taking the time to do it properly is 
        understandable, considering what a mess templates in C++ have turned out to 
        be. <footnote><para><quote>C++: An octopus made by nailing extra legs
        onto a dog.</quote></para></footnote>.</para>
        
        <para>The C#/.NET implementation of generics is based on work done
        by Don Syme and Andrew Kennedy at Microsoft Research in the UK.
        They released a prototype of their implementation codenamed
        <firstterm>Gyro</firstterm> as a set of files to be extracted over the
        source to to Microsoft's <firstterm>Shared Source<xref linkend="rotor"/> 
        </firstterm> version of the .NET Framework. 
        Their work<xref linkend="pldi2001"/> was presented at
        the 2001 Programming Language Design and Implementation (PLDI) convention. 
        </para>
        
        <sect2>
            <title>Generics in action.</title>
            
            <para>In the summer of 2004, Microsoft shipped the first beta
            version of .NET 2.0, including generics support for both VB.NET and
            C#, as well as additional classes in the BCL taking advantage of
            this support.</para>
            
            <para>More specifically, it shipped with a new namespace: 
            <type>System.Collections.Generic</type> In this namespace, classes
            and interfaces taking advantage of the generics functionality to 
            provide typesafe containers can be found. Here's an example of
            how one could use <type>Dictionary&lt;V, K&gt;</type>:</para>
            <programlisting>
        <![CDATA[   
Dictionary<string, int> myMap = new Dictionary<int>();
myMap["answer"] = 42;
myMap["airspeed velocity of an unladen European Swallow"] = 10;
]]></programlisting>     
            <para>What we are witnessing here is the
            <emphasis>instantiation</emphasis> of a generic type. A
            <type>Dictionary&lt;V, K&gt;</type> cannot be used directly - type
            parameters have to be specified for K and V.</para> 
        
            <para>In this case, there is no boxing involved even though a 
            value type (int) is stored in the collection. Also, since the types
            involved are known at compile time, there is no need for a runtime
            type check such as that involved in a cast. The instantiation
            of the dictionary is specialized for the types used, just as if 
            you (or a code generator) had written it yourself. This lack of
            boxing when storing value types is what differentiates the Java
            implementation of generics from the .NET one, as we shall see 
            later on.</para>  
            
            <para>Further, here is an example of an implementation of a 
            linked list using generics (this example is 
            taken from the .NET 2.0 documentation<xref linkend="linklistexample"/>)
            :</para>
            <programlisting>
        <![CDATA[
  
using System;
using System.Collections.Generic;

public class MyList<T>//type parameter T in angle brackets
{
        private Node head;
        // The nested type is also generic on T.
        private class Node          
        {
            private Node next;
            //T as private member data type:
            private T data;          
            //T used in non-generic constructor:
            public Node(T t)         
            {
                next = null;
                data = t;
            }
            public Node Next
            {
                get { return next; }
                set { next = value; }
            }
            //T as return type of property:
            public T Data            
            {
                get { return data; }
                set { data = value; }
            }
        }
        public MyList()
        {
            head = null;
        }
        //T as method parameter type:
        public void AddHead(T t)     
        {
            Node n = new Node(t);
            n.Next = head;
            head = n;
        }

        public IEnumerator<T> GetEnumerator()
        {
            Node current = head;

            while (current != null)
            {
                yield return current.Data;
                current = current.Next;
            }
        }
    }
]]></programlisting>
            <para>When you instantiate a <type>List&lt;T&gt;</type>, the T will
            be substituted with the type you provide for T.</para>
            
            <para>Although we won't explore it further, it is worth mentioning
            that the <function>GetEnumerator()</function> method with its
            <function>yield</function> keyword is an example of one of the other
            three prominent new features of C# 2.0: Iterators.</para>   
        </sect2>   
        
        <sect2>
            <title>Application of generics</title>
            <para>Generics are not restricted to being used on classes. You can
            also have generic methods, generic interfaces and generic delegates.
            The BCL provides several generic delegates, of which this one is a 
            good example:</para>
<programlisting>
public sealed delegate bool Predicate&lt;T&gt;(
    T obj
);
</programlisting>
            <para>Combined with anonymous methods, you can use the above delegate
            type like this:</para><programlisting>
            <![CDATA[

int[] arr = new int[100];

// fill the array with integers

int[] evenNumbers = Array.FindAll<int>( arr, delegate(val)
{
    return (val % 2) == 0; // This block is an anonymous delegate, similar to a 
                           // closure or lambda function in other languages.
                           // It has full access to local and member variables
                           // of the enclosing lexical block.
});
]]>         
            </programlisting>
            
            <para>In the above example, the implementation of
            <function>Array.FindAll</function> will call the predicate(defined
            in the anonymous block) for each element in the original array, and
            return a new arrays with only the elements for which the predicate
            returns true (in this case, only the even numbers in the original
            array).</para>
            
            <para>The second parameter to <function>FindAll</function> is an
            instance of the <function>Predicate&lt;T&gt;</function> delegate
            type. The compiler is able to infer the type of the delegate 
            automatically</para>
                        
        </sect2>
            
                        

        <!-- examples -->
        <!-- type inference -->
        <!-- type constraints -->
        <!-- restrictions - Type variables cannot be used to specify a base
        class. No con -->
        <!-- Generics in the BCL -->
        <!-- Reflecting on generic instantiations -->

        <sect2>
            <title>Performance of generics</title>
            <para>
                Since casts and boxing can be eliminated through the use of
                generics, generic types will outperform their non-generic
                counterparts by a significant factor. The following (rather
                unscientific) benchmark gives a perspective on the differences:
            </para>
<programlisting>
<![CDATA[
#region Using directives

using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

#endregion

namespace ConsoleApplication5
{
    class Program
    {
        static void Main( string[] args )
        {
            Random rand = new Random();
            ArrayList arrayList = new ArrayList( 1000000 );

            int ticks = Environment.TickCount;
            for ( int i = 0; i < arrayList.Capacity; i++ )
                arrayList.Add( rand.Next() );

            arrayList.Sort();
            Console.WriteLine( "ArrayList: {0}", Environment.TickCount - ticks );

            ticks = Environment.TickCount;
            List<int> genericList = new List<int>( 1000000 );
            for ( int i = 0; i < genericList.Capacity; i++ )
                genericList.Add( rand.Next() );
            genericList.Sort();
            Console.WriteLine( "List<int>: {0}", Environment.TickCount - ticks );

        }
    }
}
]]>
</programlisting>
        </sect2>
        <para>On the author's machine, the above gives the following output:</para>
            <screen>
<![CDATA[
T:\ConsoleApplication5\ConsoleApplication5\bin\Release>ConsoleApplication5.exe 
ArrayList: 5207                                                                
List<int>: 1402   
]]>                                                                   
        </screen>
        <para>Although this test is rather contrived, it gives a good rough image
        of the performance differences involved when choosing a generic
        approach over an object-based one.</para>       
    </sect1>
    <sect1>
        <title>The implementation.</title>        
        <para>In .NET, the generics design pervades the entire runtime and the
        .NET type system. This in contrast to, as we shall investigate later,
        the approach taken by the implementation of generics in the JVM. The
        .NET runtime natively understands generic types and knows that they are
        different from non-generic types.</para>

        <para>To show that the CLR natively understands generics, let's take a
        look at an example:</para>
        <programlisting>
<![CDATA[

using System;

namespace Test
{
    class Generic<T>
    {
        public Generic( T t )
        {
            this.t = t;
        }

        public string Value()
        {
            return this.t.ToString();
        }
        private T t;
    }

    class NonGeneric
    {
        public NonGeneric( object o )
        {
            this.o = o;
        }

        public string Value()
        {
            return this.o.ToString();
        }

        private object o;
    }
    class Test
    {
        public static void Main()
        {
            string s = "42";
            Generic<string> g = new Generic<string>( s );
            string res = g.Value();
            Console.WriteLine( res );

            Generic<object> g2 = new Generic<object>( s );
            res = g2.Value();
            Console.WriteLine( res );

            NonGeneric ng = new NonGeneric( s );
            res = ng.Value();
            Console.WriteLine( res );
        }
    }
}

]]>
        </programlisting>
        <para>Now let's look at the CIL generated from the generic class
        definition. We use the IL Disassembler(ildasm.exe) which ships
        with the .NET Framework SDK to get the following listing:</para>
        <programlisting>
<![CDATA[


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi beforefieldinit Test.'Generic`1'<([mscorlib]System.Object) T>
       extends [mscorlib]System.Object
{
  .field private !T t
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!T t) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ldarg.0
    IL_0008:  ldarg.1
    IL_0009:  stfld      !0 class Test.'Generic`1'<!T>::t
    IL_000e:  nop
    IL_000f:  ret
  } // end of method 'Generic`1'::.ctor

  .method public hidebysig instance string 
          Value() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  1
    .locals init (string V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldflda     !0 class Test.'Generic`1'<!T>::t
    IL_0006:  constrained. !T
    IL_000c:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0011:  stloc.0
    IL_0012:  br.s       IL_0014

    IL_0014:  ldloc.0
    IL_0015:  ret
  } // end of method 'Generic`1'::Value

} // end of class Test.'Generic`1'

]]>
        </programlisting>
        <para>The `1 syntax means that we are dealing with a generic
        type. Additionally, the <function>constrained.</function> instruction
        is specific to generic types.</para> 
        
        <para>Let's compare with the code emitted for a non-generic
        type:</para>
        
        <programlisting>
        <![CDATA[
.class private auto ansi beforefieldinit Test.NonGeneric
       extends [mscorlib]System.Object
{
  .field private object o
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(object o) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ldarg.0
    IL_0008:  ldarg.1
    IL_0009:  stfld      object Test.NonGeneric::o
    IL_000e:  nop
    IL_000f:  ret
  } // end of method NonGeneric::.ctor

  .method public hidebysig instance string 
          Value() cil managed
  {
    // Code size       16 (0x10)
    .maxstack  1
    .locals init (string V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      object Test.NonGeneric::o
    IL_0006:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_000e

    IL_000e:  ldloc.0
    IL_000f:  ret
  } // end of method NonGeneric::Value

} // end of class Test.NonGeneric
]]>
    </programlisting>
    <para>Here, for a non-generic class,  there is no use of the `1 construct.</para>

    <para>Unfortunately, the current beta release of the Microsoft 2.0
    Framework does not contain a specification for the instructions and the
    associated syntax used to implement generics in CIL. This will probably be
    fixed in future releases. At the very least, documentation will be
    provided when the generics mechanism has been included in the ECMA and ISO
    standards.</para>

    <sect2>
        <title>Instantiating a generic type</title> 
       <para>Instantiation of generic types happen at load time. When the Just
       In Time (JIT) compiler encounters a generic type, it will create native
       code for that instantiation. Of course, if there is a previous
       instantiation of that particular generic type for that specific set of
       type parameters, the implementation will be reused.</para>
    </sect2>
    
    <sect2>
        <title>Constraints</title>
        <para>The way generics are implemented in .NET leaves us with one 
        problem:</para>
        <programlisting><![CDATA[
public class Foo<T>
{
   public void Method( T t )
   {
      T.Bar();
   }
}]]>
        </programlisting>
        <para>Since the generic types are instantiated at runtime, how can
        the compiler know that the type <type>T</type> will support a method
        <function>Bar()</function>? The answer is: It can't. The above will
        not compile with a C# compiler.</para>
        
        <para>The solution is to introduce <firstterm>constraints</firstterm>
        on the type being used for <type>T</type>. We can rewrite the above:</para>
<programlisting><![CDATA[
public interface IBar
{
   void Bar();
}

public class Foo<T> where T : IBar // this is a constraint
{
   public void Method( T t )
   {
      T.Bar();
   }
}]]>
        </programlisting>  
       <para>The <firstterm>where</firstterm> clause indicates that
        <type>Foo</type> can only be instantiated for classes implementing the
        <type>IBar</type> interface. There are five types of constraints, and a
        generic type can have an unlimited number of constraints:</para>
        <variablelist>
            <varlistentry><term>class</term>
                <listitem>The generic type must be a reference type(allocated
                on the heap).</listitem>
            </varlistentry>
            <varlistentry><term>struct</term>
                <listitem>The generic type must be a value type.</listitem>
            </varlistentry>
            <varlistentry><term>new</term>
                <listitem>The generic type must support a parameter-less
                constructor.</listitem>
            </varlistentry>
            <varlistentry><term>'interface'</term>
                <listitem>The type must implement the interface 'interface'.
                </listitem>
            </varlistentry>
            <varlistentry><term>'class'</term>
                <listitem>The type must derive from the class 'class'.</listitem>
            </varlistentry>
        </variablelist>
        
    </sect2>
    <sect2>
        <title>Code sharing</title>

        <para>If the native code emitted for a previous
        instantiation of a type is considered <quote>compatible</quote> with
        another type, this instantiation can be reused as well. All
        instantiations of a generic type parameterized on a class type (not a
        value type) can share the same native code. For example, the
        instantiations of <function>List&lt;string&gt;</function> and
        <function>List&lt;Button&gt;</function> will typically be identical,
        since neither <type>string</type> nor <type>Button</type> are value
        types, and the lists merely have to store references to the objects. A
        reference is represented as a native pointer type in machine
        code (Occupying 4 bytes on a 32 bit architecture like the x86).</para>

        <para>Instantiations for value types cannot so easily be shared, since
        value types typically have different sizes. For example, for a
        <type>List&lt;int&gt;</type>, the list contains items that each occupy 4
        bytes. For a <type>List&lt;double&gt;</type>, however, each item occupies 8
        bytes. This means that the binary layout of the list and its
        implementation will differ.  Although it is conceivable that an advanced
        JIT could do some degree of code sharing also in this case, this is not
        currently implemented.</para>

    </sect2>        
    </sect1>
    
    <sect1>
        <title>.NET generics versus Java generics</title>
        <para>When Sun Microsystems released Java 2, Standard Edition 5.0
        earlier this year, generics support was one of the big advancements
        over earlier versions. With this release, they beat .NET by having a
        working, non-beta, implementation of generics out on the market. The 
        .NET release featuring generics is still in beta.</para>

        <para>The Java implementation of generics was based on a research
        project named Pizza<xref linkend="pizzacompiler"/>, which was
        later turned into a Java Specification Request (JSR).</para>

        <para>While the syntax of generics in Java looks pretty similar to
        that of C#, the underlying implementation is vastly different. Let us
        look at an example:</para>
        <programlisting>
        <![CDATA[

public class List<T>
{
    public void add( T t )
    {
        // ...
    }

    public T getAt( int i )
    {
        // ...
    }

    // ...

    private T[] list;
}

public class Test
{
    public static void main( String[] args )
    {
        List<String> stringList = new List<String>();
        stringList.add( "The answer is " );
        stringList.add( "42" );

        String s = stringList.getAt( 1 );
        System.out.println( s );
    }
}
]]>
        </programlisting>
        <para>Except for the camelCase vs PascalCase issues, this syntax is
        pretty much identical to that of C#. However, what happens under the
        hood when the code is compiled is different.</para>

        <para>If the C# compiler had encountered the above example, it would
        have emitted CIL that indicated that the <type>List</type> class was
        a generic type, and it would have inserted CIL in the
        <function>main()</function> to instantiate a specialization of the
        List parameterized on the <type>String</type> class. The Java compiler
        does no such thing.</para>

        <para>In Java, the runtime (the JVM) does not have a concept of generic
        types at all. The JVM bytecode instruction set has not been modified
        to accommodate generics. The compiler is therefore limited to emitting
        the same bytecode as for a non-generic class. It has been speculated
        that this approach was chosen so that generic classes would run on
        downlevel JVMs (pre 5.0), but it has later turned out that this isn't
        true. A compiled generic class file will not run on downlevel JVMs.
        (JSR 14 states: <quote>It is explicitly not required that the system
        a) Provide downward binary compatibility: It is not necessary that class 
files compiled under the generic compiler should run on previous releases, whether they 
use generics or not.</quote>)</para>

        <para>When the Java compiler encounters a generic class, it performs
        an operation on the generic class called <firstterm>type
        erasure</firstterm>. Type erasure basically means that the compiler
        strips out all the parametric types and replaces them with
        <type>Object</type>. The compiler would turn the above example into
        this:</para>
        <programlisting>
        <![CDATA[

public class List
{
    public void add( Object t )
    {
        // ...
    }

    public Object getAt( int i )
    {
        // ...
    }

    // ...

    private Object[] list;
}

public class Test
{
    public static void main( String[] args )
    {
        List stringList = new List();
        stringList.add( "The answer is " );
        stringList.add( "42" );

        String s = (String)stringList.getAt( 1 );
        System.out.println( s );
    }
}
]]>
        </programlisting>
        <para>Here, all parametric type information has been stripped out and
        the result resembles the implementation of a <type>List</type> class
        prior to the introduction of generics. It is worth noting that the
        compiler actually inserts casts for invocations of the
        <function>getAt</function> method. After performing the type erasure,
        the class is compiled just like a regular non-generic class, and the
        bytecode emitted bears no mark of being the end result from a generic
        type.</para>
        
        <sect2>
            <title>Wildcards</title>
            <para>Java generics support a feature called 
            <firstterm>wildcards</firstterm>:</para>
            <programlisting><![CDATA[Foo<?> f;]]></programlisting>
            <para>Here, <varname>f</varname> can point to Foo specialized
            on <emphasis>any</emphasis> type, like Foo&lt;int&gt; and
            Foo&lt;String&gt;. .NET currently has no equivalent to this.</para>            
        </sect2>

        <sect2>
        <title>Implications of the Java approach</title>
            <para>The Java approach has some advantages: It is rather simple
            to implement, and it requires no changes to the JVM or the Java
            bytecodes. However, these advantages are far outweighed by the
            disadvantages. As one can see, when using generics in Java, the
            runtime casts are merely hidden, and you lose the performance
            benefit gained by using generics in .NET. If you parameterize a
            generic Java type on a value type, the Java compiler will actually
            <emphasis>insert</emphasis> the same kind of boxing and unboxing
            operations that are some of the motivation for introducing
            generics in .NET. The end result is that a Java generic container
            class gives you no performance benefit over an equivalent
            <type>Object</type>-based container.</para>

            <para>Another consequence of the Java implementation is that no
            information about the genericity of a class is available at
            runtime. Any attempt to perform reflection against our
            <type>List</type> class will reveal nothing more than that it's a
            class of type <type>List</type>. There is no way to retrieve
            information about which type it was parameterized on, or that it
            is in fact a generic type. All that information has been thrown
            away by the compiler. The .NET implementation, on the other hand,
            supports full reflection of generic types at runtime. The central
            class in .NET reflection, the <type>Type</type> class, contains a
            wide range of methods and properties that allow you to retrieve
            information about a generic type and the types it has been
            parameterized on.</para>
        
        </sect2>
    </sect1>
    <bibliography>
        <biblioentry id="vsip">
            <title>
                Visual Studio Industry Partner Program
                <ulink url="www.vsipdev.com">
                www.vsipdev.com</ulink></title>
            <pubdate>August 2003</pubdate>
        </biblioentry>
        <biblioentry id="ecma335">
            <title>
                <ulink url="http://www.ecma-international.org/publications/standards/Ecma-335.htm">http://www.ecma-international.org/publications/standards/Ecma-335.htm</ulink>
            </title>
        </biblioentry>
        <biblioentry id="iso23271">
            <title>
                <ulink url="http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36769">http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36769</ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="wikipgen">
            <title>
                <ulink url="http://en.wikipedia.org/wiki/Generic_programming">http://en.wikipedia.org/wiki/Generic_programming</ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="rotor">
            <title> 
                <ulink url="http://sscli.net">Microsoft Shared Source CLI - http://sscli.net
                </ulink>
            </title>
        </biblioentry>        
        
        <biblioentry id="pldi2001">
            <authorgroup>
                <author>
                    <firstname>Don</firstname>
                    <surname>Sym</surname>
                </author>
                <author>
                    <firstname>Andrew</firstname>
                    <surname>Kennedy</surname>
                </author>
            </authorgroup>
            <title>The Design and Implementation of Generics for the .NET Common Language Runtime</title>
            <pubdate>May 02, 2001</pubdate>
        </biblioentry>
        
        <biblioentry id="linklistexample">
            <title>
                <ulink url="http://msdn2.microsoft.com/library/0x6a29h6.aspx">http://msdn2.microsoft.com/library/0x6a29h6.aspx</ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="pizzacompiler">
            <title>
                <ulink
                url="http://pizzacompiler.sourceforge.net/">http://pizzacompiler.sourceforge.net/</ulink>
            </title>
        </biblioentry>
        <!--

        <biblioentry id="csgenericsintro">
            <authorgroup>
                <author>
                    <firstname>Juval</firstname>
                    <surname>Lowry</surname>
                </author>
            </authorgroup>
            <title>
                <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnvs05/html/csharp_generics.asp">
                An Introduction to C# Generics</ulink></title>
            <pubdate>August 2003</pubdate>
        </biblioentry>
         
        
         
        
        
        
        <biblioentry id="csspec">
            <title>
                <ulink url="http://download.microsoft.com/download/8/1/6/81682478-4018-48fe-9e5e-f87a44af3db9/SpecificationVer2.doc">'
                    C# 2.0 Specification
                </ulink>
            </title>
        </biblioentry>-->
        
        

        
    </bibliography>
</article>


<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN" 
    "file:///t:/docbook-dtd/docbookx.dtd">
<!--  
    vim:et ts=4 tw=78
-->
<article>
    <artheader>
        <title>Generics in C#</title>
        <author>
            <firstname>Arild</firstname>
            <surname>Fines</surname>
        </author>
    </artheader>
    <abstract>
        <para>
            This essay will discuss a new mechanism that will be introduced in
            version 2.0 of the <firstterm>Common Language
            Runtime</firstterm>(CLR), known as <firstterm>generics</firstterm>.
            We will take a look at how generics will be used when programming in
            various programming languages targetting the CLR, with an emphasis
            on the <firstterm>C# programming language</firstterm>. We will
            review how the CLR implements generics, and compare the
            implementation of generics in .NET with the way other environments,
            such as the Java Virtual Machine and to a lesser degree, C++,
            perform the same task.
        </para>
    </abstract>
    <sect1>
        <title>What is the Common Language Runtime?</title>
        <para>The Common Language Runtime(CLR) is the central component of
        Microsoft's new development initiative <firstterm>.NET</firstterm>. It
        encompasses a runtime environment with rich support for a variety of
        modern object-oriented programming languages, allowing them to
        interoperate on a binary level. Components written in one language can
        be consumed directly by components written in another language as long
        as they both target the CLR.</para>

        <para>Accompanying the first release of .NET was a new programming
        language, C#, which takes full advantage of the features available in
        the CLR.</para>
        
        <para>The .NET initiative in general was intended to replace Microsoft's
        component technology known as COM/DCOM as the premier choice for
        enterprise development on the Microsoft Windows platform, and has been
        marketed aggressively to compete against Sun Microsystem's Java
        programming language and the J2EE architecture.</para>

        <para>Microsoft's flagship development environment <firstterm>Visual
        Studio</firstterm> has a broad range of support for programming against
        the CLR. The current version of Visual Studio, Visual Studio 2003, lets
        developers target the CLR using 4 different languages: C++, Visual
        Basic, C# and Visual J#. It also allows third party compiler writers to
        integrate their compilers into the environment through the<link
        linkend="vsip"> <firstterm>Visual Studio Industry Partner
        Program</firstterm></link>.</para>

        <para>The CLI has been standardized through the <firstterm>European Computer
        Manufacturers Association</firstterm>(ECMA) and the <firstterm>International
        Standards Organization</firstterm>(ISO) under the designations <link
        linkend="ecma335">ECMA-335</link> and
        <link linkend="iso23271">ISO/IEC 23271</link>, respectively.</para>
        
        <sect2>
        <title>The CLR's type system</title>
       <para> The CLR's type system reflects the fact that it is targetted
        primarily(but not exclusively) towards object-oriented languages. It
        supports two main categories of types:</para>
        <variablelist>
            <varlistentry><term>objects</term>
                <listitem>Object types are always allocated on the heap. Any
                representation of an object as a local variable merely consists
                of a pointer to the object.</listitem>
            </varlistentry>
            <varlistentry><term>value types</term>
                <listitem>value types are essentially nothing more than a
                sequence of bytes, and are represented as such on a program's
                stack. They are allocated either on the runtime
                stack or inline in objects that contain them. They support
                methods, but not inheritance, although they can implement one or
                more interfaces. All primitive types, such as integers and
                floats, are represented in the CLR type system as value
                types</listitem>
            </varlistentry>
        </variablelist>

        <para>The inherent impedance between these two categories is one of the things
        that make a mechanism like generics desirable.</para>

        <para>The CLR also has support for a wide variety of other useful types,
        such as pointers, arrays and <firstterm>delegates</firstterm>(type safe
        function pointers), but they are implemented in terms of one of the
        above types.</para>
        
        <para>In the CLR, the <type>Object</type> type serves as the root of its
        single inheritance hierarchy. Objects are not allowed to have more
        than one superclass, but they can implement any number of
        interfaces.</para>
        
        <!-- structs/valuetypes vs heap objects -->
        <!-- delegates -->

            <sect3>
            <title>The Common Type System(CTS)</title>
            <para>The <firstterm>Common Type System</firstterm> is a specification
            which represents the minimum of types a language targetting the CLR
            should be able to consume and produce. It is a subset of the full
            type system. Partition II of the <link linkend="ecma335">ECMA
            standard</link> describes the CTS.</para>

            </sect3>
        </sect2>
        
        <sect2> <title>Common Intermediate Language(IL)</title>
        <para>The <firstterm>Common Intermediate Language</firstterm>(CIL) is
        the language output by a compiler targetting the CLR. The language
        consists of a series of instructions manipulating a virtual stack based
        machine. However, this stack machine is intended to be purely
        hypothetical - CIL is designed to be compiled to native machine code
        before it is executed. This in contrast to the bytecodes of the JVM,
        which were originally designed to be executed directly by such a stack
        machine, implemented on top of the real hardware.</para>

        <para>CIL is described in Partition III of the <link
        linkend="ecma335">ECMA standard</link> </para>
        
        <para>The term MSIL(Microsoft
        Intermediate Language) describes Microsoft's implementation of CIL. This
        abbreviation is often (incorrectly) used interchangeably with CIL and/or
        IL.</para> 
        </sect2>
        
    </sect1>
    <sect1>
        <title>What are generics?</title>
        <para>Wikipedia <link linkend="wikipgen">defines</link> generics as
        <quote> technique that allows one value to take different datatypes
        (so-called polymorphism) as long as certain contracts such as subtypes
        and signature are kept.</quote> It further defines <firstterm>generic
        programming</firstterm> as <quote>the programming style emphasizing use
        of this technique.</quote></para>
        
        <para>This is a rather abstract definition, but the concept of generics 
        eventually boil down to the ability to parameterize a custom datatype
        on one or more types. The canonical example of a parameterized type is
        a collection class that can be parameterized on the types it holds. For
        example, a <type>List</type> class can be configured to hold either 
        integers or<type>Foo</type> objects, but not at the same time. With
        .NET generics in C#, the use of such a class would look like this:</para>
        <programlisting>
        <![CDATA[        
List<Foo> list = new List<Foo>();
list.Add( new Foo(42) );
list.Add( new Foo(84) );

Foo foo = list[0]; // get the first item in the list
        ]]>        
        </programlisting>
        <para>Since this list is parameterized on the <type>Foo</type>, any attempt to insert
        objects of another type would generate a compile-time error:</para>
        <programlisting>
        <![CDATA[
        
list.Add( 42 ); // ERROR: int is not a Foo
list.Add( new Bar() ); // ERROR: Bar is not a Foo

        ]]>        
        
        </programlisting>
        
        <para>Of course, normal polymorphic substitutability rules apply. If,
        in the above example, <type>Bar</type> was a class deriving from
        <type>Foo</type>, the insertion would be allowed by the compiler.</para>
        
        <sect2>
           <title>What exactly is <quote>polymorphism</quote>, and what does it
            have to do with generics?</title> 
            
            <para>The term polymorphism
            derives from the Greek words <quote>poly</quote>, meaning
            <quote>many</quote>, and <quote>morphos</quote>, meaning <quote>
            shape.</quote><footnote><para>Similarly, the word
            <quote>politics</quote> derives from <quote>poly</quote>, meaning 
            <quote>many</quote> and the word <quote>ticks</quote>, meaning
            <quote>nasty little bugs.</quote>.</para> </footnote> 
            
            In other words, it describes an entity that can take
            on many shapes. The most common application of the term in computer
            science is to describe the way most object oriented programming
            languages dispatch method calls on a type. However, it applies
            equally well to <quote>function overloading</quote>(several
            functions having the same name, but different argument lists) and
            <quote>generics</quote>. In generics, the generic type takes on a
            different 'shape' for each different type it is parameterized on.
            </para>
        </sect2>
        
        <!-- C# programmers coming from C++ - miss templates -->
        <!-- define "polymorphism" -->
        <!-- parametric polymorphism vs dynamic/virtual approaches 
        advantages of pp -->
        <!-- other languages supporting 'generics'(in a broad sense) -->

        <sect2>
        <title>The motivation for generics in .NET</title>
        In versions of the CLR prior to (the not yet released)2.0, developers
        have had certain options when it came to storing their custom types in 
        containers:
        <variablelist>
            <varlistentry>
                <term>Use the standard object-based containers.</term>
                <listitem><para>The .NET Framework Base Class Library(BCL)
                ships with an adequate set of container classes, all storing
                items of type <type>Object</type>. Using these containers for
                value types had certain performance implications since it
                incurred the cost of <firstterm>boxing</firstterm>. It also
                relinquished compile-time type safety, since the compiler had
                no way of checking that only objects of one type were inserted
                into the container. Additionally, retrieving objects from the
                container required a cast operation. This cast was not entirely
                free, since the compiler had to insert code to do a runtime
                type check and potentially cast an exception if the real object
                type didn't match the type cast to.</para></listitem>
            </varlistentry>
            
            <varlistentry>
                <term>Write custom containers from scratch.</term>
                <listitem><para>You could, of course, always write your
                IntegerList class from scratch. This would avoid the boxing
                problem associated with the use of the standard containers and
                value types(described above), and there would be no need for a
                cast when retrieving an object from the list.</para>
                
                <para>The obvious downside is of course that writing such
                custom containers is extremely dull gruntwork. Additionally,
                you would rarely need only a single specialized container,
                leading to the explosion of <type>IntegerList</type>,
                <type>FloatList</type> and <type>FooList</type> objects all
                over the place. If you wanted to change the algorithm used or
                the interface of these classes, you needed to ensure that the
                changes were made in all of them.</para>
                </listitem>                
            </varlistentry>
            <varlistentry>
                <term>Use a code generator.</term>
                <listitem><para>Of course, since writing a custom container
                from scratch is <quote>extremely dull gruntwork</quote>, it is
                a perfect candidate for automation by a computer. There are
                several tools out there that take as input the types the
                container should store, and spits out a perfect custom
                container that requires no casting or boxing, even for primitives.
                </para></listitem>
            </varlistentry>
        </variablelist>
        <!-- use explicit interface implementation, derive from CollectionBase, use ArrayList-->
        <!-- boxing, unboxing -->
        <!-- code generation -->
        <!-- examples -->
        </sect2>
        <sect2>
            <title>Uhh... what's this <quote>boxing</quote> thing?</title>
            <para>Essentially, boxing is a mechanism that allows you to store
            value types on the heap as a regular object. As the reader may
            remember, value types as local variables or member variables are
            stored merely as the sequence of bytes which they represent,
            instead of as a pointer to a heap object as with reference types.</para>
            
            <para>In order to store a value type in a container class that holds
            only <type>Object</type>s, you therefore need to copy it to a heap
            object so you can pass that heap object's reference to the container's
            <function>Add()</function> method.</para>
            
            <para>When the value type is retrieved from the container, the reverse
            operation, called <firstterm>unboxing</firstterm>, is needed. This 
            extracts the bytes for the value type and recreates it on the stack
            as a local variable.</para>
            
            <para>While boxing and unboxing are conceptually very elegant ways
            of solving the heap object/value type impedance problem, there is 
            little question that there is a performance cost inherent in it.
            </para>
        </sect2>
       
    </sect1>
    <sect1>
        <title>.NET generics</title>
        <para>A preliminary specification for version 2.0 of the C# programming
        language was released in October 2003. It contained, as everyone had
        expected, a proposal for a generics mechanism, in addition to other new
        features as <firstterm>anonymous methods</firstterm>,
        <firstterm>iterators</firstterm> and <firstterm>partial types.</firstterm>
        While the other three features are exciting in their own right, they will 
        not be discussed any further here.
        </para>
        
        <para>Comments made by Microsoft employees involved with the language
        design on C# and .NET newsgroups and blogs indicated that generics
        was a feature they had wished to include in the very first release of C#,
        but that time did not permit it. Taking the time to do it properly is 
        understandable, considering what a mess templates in C++ have turned out to 
        be. <footnote><para><quote>C++: An octopus made by nailing extra legs
        onto a dog.</quote></para></footnote>.</para>
        
        <para>The C#/.NET implementation of generics is based on work done
        by Don Syme and Andrew Kennedy at Microsoft Research in the UK.
        They released a prototype of their implementation codenamed
        <firstterm>Gyro</firstterm> as a set of files to be extracted over the
        source to to Microsoft's <firstterm><link linkend="rotor">Shared Source</link> 
        </firstterm> version of the .NET Framework. <link linkend="pldi2001"> 
        Their work</link> was presented at 2001's Programming Language Design
        and Implementation (PLDI) convention. </para>
        
        <sect2>
            <title>Generics in action.</title>
            
            <para>In mid-2004, Microsoft shipped the first beta of .NET 2.0, 
            ïncluding generics support for both VB.NET and C#, as well as 
            additional classes in the BCL taking advantage of this support.</para>
            
            <para>More specifically, it shipped with a new namespace: 
            <type>System.Collections.Generic</type> In this namespace, classes
            and interfaces taking advantage of the generics functionality to 
            provide typesafe containers can be found. Here's an example of
            how one could use <type>Dictionary&lt;V, K&gt;</type>:</para>
            <programlisting>
        <![CDATA[   
Dictionary<string, int> myMap = new Dictionary<int>();
myMap["answer"] = 42;
myMap["airspeed velocity of an unladen European Swallow"] = 10;
]]></programlisting>     
            <para>What we are witnessing here is the
            <emphasis>instantiation</emphasis> of a generic type. A
            <type>Dictionary&lt;V, K&gt;</type> cannot be used directly - type
            parameters have to be specified for K and V.</para> 
        
            <para>In this case, there is no boxing involved even though a 
            value type(int) is stored in the collection. Also, since the types
            involved are known at compile time, there is no need for a runtime
            type check such as that involved in a cast. The instantiation
            of the dictionary is specialized for the types used, just as if 
            you(or a code generator) had written it yourself. This lack of
            boxing when storing value types is what differentiates the Java
            implementation of generics from the .NET one, as we shall see 
            later on.</para>  
            
            <para>Further, here is an example of an implementation of a 
            linked list using generics(this example is <link linkend="linklistexample">
            taken from the .NET 2.0 documentation</link>):</para>
            <programlisting>
        <![CDATA[
  
using System;
using System.Collections.Generic;

public class MyList<T>//type parameter T in angle brackets
{
        private Node head;
        // The nested type is also generic on T.
        private class Node          
        {
            private Node next;
            //T as private member data type:
            private T data;          
            //T used in non-generic constructor:
            public Node(T t)         
            {
                next = null;
                data = t;
            }
            public Node Next
            {
                get { return next; }
                set { next = value; }
            }
            //T as return type of property:
            public T Data            
            {
                get { return data; }
                set { data = value; }
            }
        }
        public MyList()
        {
            head = null;
        }
        //T as method parameter type:
        public void AddHead(T t)     
        {
            Node n = new Node(t);
            n.Next = head;
            head = n;
        }

        public IEnumerator<T> GetEnumerator()
        {
            Node current = head;

            while (current != null)
            {
                yield return current.Data;
                current = current.Next;
            }
        }
    }
]]></programlisting>
            <para>When you instantiate a <type>List&lt;T&gt;</type>, the T will
            be substituted with the type you provide for T.</para>
            
            <para>Although we won't explore it further, it is worth mentioning
            that the <function>GetEnumerator()</function> method is an example
            of one of the other three prominent new features of C# 2.0: 
            Iterators.</para>   
        </sect2>   
        
        <sect2>
            <title>Application of generics</title>
            <para>Generics are not restricted to being used on classes. You can
            also have generic methods, generic interfaces and generic delegates.
            The BCL provides several generic delegates, of which this one is a 
            good example:</para>
<programlisting>
public sealed delegate bool Predicate&lt;T&gt;(
	T obj
);
</programlisting>
            <para>Combined with anonymous methods, you can use the above delegate
            type like this:</para><programlisting>
            <![CDATA[

int[] arr = new int[100];

// fill the array with integers

int[] evenNumbers = Array.FindAll<int>( arr, delegate(val)
{
    return (val % 2) == 0;
}
]]>         
            </programlisting>
            
            <para>In this case, the second parameter to <function>FindAll</function>
            is a <function>Predicate&lt;T&gt;</function>.</para>
                        
        </sect2>
            
                        

        <!-- examples -->
        <!-- type inference -->
        <!-- type constraints -->
        <!-- restrictions - Type variables cannot be used to specify a base
        class. No con -->
        <!-- Generics in the BCL -->
        <!-- Reflecting on generic instantiations -->

        <sect2>
            <title>Performance of generics</title>
            <para>
                Since casts and boxing has been eliminated, generic types
                will outperform their non-generic counterparts by a 
                significant factor. The following(rather unscientific) benchmark
                gives a perspective on the differences:                
            </para>
<programlisting>
<![CDATA[
#region Using directives

using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

#endregion

namespace ConsoleApplication5
{
    class Program
    {
        static void Main( string[] args )
        {
            Random rand = new Random();
            ArrayList arrayList = new ArrayList( 1000000 );

            int ticks = Environment.TickCount;
            for ( int i = 0; i < arrayList.Capacity; i++ )
                arrayList.Add( rand.Next() );

            arrayList.Sort();
            Console.WriteLine( "ArrayList: {0}", Environment.TickCount - ticks );

            ticks = Environment.TickCount;
            List<int> genericList = new List<int>( 1000000 );
            for ( int i = 0; i < genericList.Capacity; i++ )
                genericList.Add( rand.Next() );
            genericList.Sort();
            Console.WriteLine( "List<int>: {0}", Environment.TickCount - ticks );

        }
    }
}
]]>
</programlisting>
        </sect2>
        <para>On the author's machine, the above gives the following output:</para>
            <screen>
<![CDATA[
T:\ConsoleApplication5\ConsoleApplication5\bin\Release>ConsoleApplication5.exe 
ArrayList: 5207                                                                
List<int>: 1402   
]]>                                                                   
        </screen>
        <para>Although this test is rather contrived, it gives a good rough image
        of the performance differences.</para>       
    </sect1>
    <sect1>
        <title>The implementation.</title>
        <sect2>Code sharing</sect2>
        <!-- <SPAN style="COLOR: black">In the case of generics, code sharing is when two or 
more “compatible” method instantiations point to the same x86 code. An example 
of this is Foo.M&lt;MyClass1&gt; and Foo.M&lt;MyClass2&gt; sharing the same 
generated x86, where MyClass1 and MyClass2 are ref types.<o:p></o:p></SPAN> -->
    </sect1>
    <sect1>
        <title>Generics in other .NET languages</title>
        <sect2>
            <title>VB.NET</title>
        </sect2>
    </sect1>
    <sect1>
        <title>C# Generics - How do they compare to Java generics?</title>
        <!-- reflectability of generic types -->
        <!-- primitives and generic types - boxing/unboxing -->
    </sect1>
    <sect1>
        <title>Comparisons to similar constructs in other programming languages</title>
        <sect2>C++ templates</sect2>
        <!-- runtime vs compile/link time -->
        <!-- code sharing -->
        <sect2><phrase>"Duck typing"</phrase> in dynamic languages</sect2>
    </sect1>
    <bibliography>
        <biblioentry id="pldi2001" xreflabel="pldi2001">
            <authorgroup>
                <author>
                    <firstname>Don</firstname>
                    <surname>Sym</surname>
                </author>
                <author>
                    <firstname>Andrew</firstname>
                    <surname>Kennedy</surname>
                </author>
            </authorgroup>
            <title>The Design and Implementation of Generics for the .NET Common Language Runtime</title>
            <pubdate>May 02, 2001</pubdate>
        </biblioentry>

        <biblioentry id="csgenericsintro" xreflabel="csgenericsintro">
            <authorgroup>
                <author>
                    <firstname>Juval</firstname>
                    <surname>Lowry</surname>
                </author>
            </authorgroup>
            <title>
                <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnvs05/html/csharp_generics.asp">
                An Introduction to C# Generics</ulink></title>
            <pubdate>August 2003</pubdate>
        </biblioentry>
         <biblioentry id="vsip" xreflabel="vsip">
            <title>
                Visual Studio Industry Partner Program
                <ulink url="www.vsipdev.com">
                www.vsipdev.com</ulink></title>
            <pubdate>August 2003</pubdate>
        </biblioentry>
        <biblioentry id="ecma335" xreflabel="ECMA335">
            <title>
                <ulink url="http://www.ecma-international.org/publications/standards/Ecma-335.htm">
                     http://www.ecma-international.org/publications/standards/Ecma-335.htm</ulink>
            </title>
        </biblioentry>
        <biblioentry id="iso23271" xreflabel="ISO23271">
            <title>
                <ulink url="http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36769">
                     http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36769</ulink>
            </title>
        </biblioentry>
        
         <biblioentry id="wikipgen" xreflabel="wikipgen">
            <title>
                <ulink url="http://en.wikipedia.org/wiki/Generic_programming">
                     http://en.wikipedia.org/wiki/Generic_programming</ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="rotor" xreflabel="Rotor">
            <title> 
                <ulink url="http://sscli.net">
                    Microsoft Shared Source CLI
                </ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="csspec" xreflabel="CSSPEC">
            <title>
                <ulink url="http://download.microsoft.com/download/8/1/6/81682478-4018-48fe-9e5e-f87a44af3db9/SpecificationVer2.doc">'
                    C# 2.0 Specification
                </ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="linklistexample" xreflabel="LINKLISTEXAMPLE">
            <title>
                <ulink url="http://msdn2.microsoft.com/library/0x6a29h6.aspx">'
                    Generic linked list example
                </ulink>
            </title>
        </biblioentry>
    </bibliography>
</article>


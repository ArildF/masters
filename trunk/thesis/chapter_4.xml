<?xml version="1.0" encoding="utf-8"?>
<chapter id="chapter_4">
  <title>The implementation</title>
  
  <sect1 id="chapter_4-sect-1">
    <title>Introducing reference counting into the CLR</title>
    
    <para>Obviously, the Rotor code base is largely built around the assumption
    that the implementation will be garbage collected. Locating all the places
    where these assumptions have been made and ripping them out to create a 
    pure reference counted runtime would be an enormous task. I therefore 
    decided on creating a dual type system in which both reference counted 
    types and types tracked by the current garbage collector exist side by 
    side.
    </para>
    
    <sect2 id="chapter_4-sect-1.1">
      <title>Telling the runtime about reference counted types</title>
      <para>If the runtime is going to support both reference counted and types
      tracked by a classic garbage collector simultaneously, there needs to be 
      a way for it to tell the difference between the two types. One possible
      approach might be to introduce new IL instructions to allocate and 
      initialize reference counted types. Instructions could also be added to 
      explicitly manage the reference counts.</para>
      
      <para>I have decided against this approach because of its rather invasive
      nature, and because of the massive amount of changes required to the 
      runtime. It would also require all compilers targeting the runtime to be 
      modified to emit the new instructions, something which is clearly not 
      feasible considering the large amount of compilers out there targetting
      IL. A less invasive approach would be far more desirable.</para>
      
      <para>What is needed in this case is a way to tell the runtime that "hey,
      this type should not be tracked by the garbage collector". A specific 
      type could be labelled in this way and the runtime would treat the type
      as a special case, tracking it using reference counting rather than 
      the garbage collector. This would ideally not require any changes to 
      existing compilers, allowing even these to take advantage of the new
      reference counting mechanism..</para>
      
      <para>Fortunately, the CLI already provides a mechanism that allows us
      to annotate types (and methods, fields, parameters etc) with arbitrary
      metadata: custom attributes. Since these are part of the standard, all
      existing CLI languages already know how to produce and consume custom
      attributes.</para>
      
      <sidebar id="chapter_4-sidebar-1">
        <title>Metadata in the CLR</title>
        <para>The CLR's type system, the <firstterm>Common Type 
        System</firstterm>, is centered around the concept of 
        <firstterm>metadata.</firstterm> From Partition I of ECMA-335
        <xref linkend="ecma-vol-1"/>:</para>
        
        <blockquote><para>New types – value types and reference types – are
        introduced into the CTS via type declarations expressed in metadata. In
        addition, metadata is a structured way to represent all information
        that the CLI uses to locate and load classes, lay out instances in
        memory, resolve method invocations, translate CIL to native code,
        enforce security, and set up runtime context boundaries. Every CLI
        PE/COFF module (see Partition II) carries a compact metadata binary
        that is emitted into the module by the CLI-enabled development tool or
        compiler. Each CLI-enabled language will expose a language-appropriate
        syntax for declaring types and members and for annotating them with
        attributes that express which services they require of the
        infrastructure. Type imports are also handled in a language-appropriate
        way, and it is the development tool or compiler that consumes the
        metadata to expose the types that the developer sees. </para>
        </blockquote>
        
        <para>In other words, metadata is the mechanism in which the runtime 
        itself and other tools obtain information about the types and their 
        attributes and operations. It doesn't stop there, though: it also 
        allows developers to create their own <emphasis>custom</emphasis>
        metadata, in the form of <firstterm>attributes.</firstterm>.</para>
        
        <para>An attribute is a type deriving from the
        <classname>System.Attribute</classname> class. It can be applied to
        classes, structs, methods, fields and parameters, as well as to
        assemblies. They can contain explicit information in the form of
        properties on the type, or they can implicitly convey information
        merely by being present on some element.</para>
        
        <para>In the C# language, attributes are expressed using square
        brackets in front of the element onto which they are applied. For
        example, the <classname>Serializable</classname> attribute indicates to
        the runtime that a type can be serialized:</para>
        
        <example><programlisting><![CDATA[
[Serializable]
public class Foo
{
  // ...
}       
]]></programlisting></example>
      
        <para><classname>Serializable</classname> is an attribute that does not
        contain any information beyond its mere presence. It is declared like 
        this:</para>
<example><programlisting><![CDATA[
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct |
   AttributeTargets.Enum | AttributeTargets.Delegate)]
public sealed class SerializableAttribute : Attribute     
{
   // ...
} 
]]></programlisting></example>
        <para>It is interesting to note that declaring custom attributes also
        requires the use of attributes to constrain which kinds of types they
        can be applied to. We can see here that
        <classname>Serializable</classname> can be applied to classes, structs,
        enums and delegates.</para> 
        
      </sidebar>
      
      <para>I have therefore decided to use a custom attribute to signify that
      a given type should be reference counted rather than garbage collected.
      Since this attribute is rather central to the runtime, I have placed it
      in the <classname>System</classname> namespace, as part of the core
      library which gets implicitly referenced by all .NET assemblies: corlib.
      The implementation can be found in
      <filename>clr/src/bcl/system/referencecountedattribute.cs</filename> and
      looks like this:</para>
<example><programlisting><![CDATA[
namespace System
{
    /// <summary>
    /// An attribute that indicates to the runtime that the applied-to type
    /// should be handled by reference counting, not M&S garbage collection.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class ReferenceCountedAttribute : Attribute
    {
        public ReferenceCountedAttribute()
        {            
        }
    }
}
]]></programlisting></example>   

      <para>This attribute can then be applied onto a class like this
      <footnote><para>Note that C# allows you to omit the
      <classname>Attribute</classname> suffix to the attribute type when
      applying it. All attribute types are required to have this suffix in the
      name, though.</para></footnote>: </para>
      
      <example><programlisting><![CDATA[
[ReferenceCounted]
public class Foo
{
   // ...
}
]]></programlisting> </example> 

      <para>The attribute does not carry any information beyond its presence on
      a class. It is restricted to classes (reference types) only; as I have 
      mentioned before, value types are allocated either on the stack or as 
      part of reference types, and thus already have predictable life times.
      XXX: Apply on interfaces?</para>
      
      <para>As can be inferred from the <classname>AttributeUsage</classname>
      attribute applied on <classname>ReferenceCountedAttribute</classname>, I
      have chosen to let the attribute be inherited to subclasses. As an
      example, let's say we have the following classes:</para> 
      
      <example><programlisting><![CDATA[
[ReferenceCounted]
public class Base
{
   // ...
}

public class Derived : Base
{
   // ...
}
]]></programlisting></example>

    <para>In my implementation, instances of both
    <classname>Derived</classname> and <classname>Base</classname> will be
    reference counted.</para>
      
    </sect2>
  </sect1>
  
  <sect1 id="chapter_4-sect-2">
    <title>Modifying the class loading process</title>
    <para>Now, with that attribute in place, the information about whether a
    given class should be reference counted gets embedded into the assembly as
    part of the metadata associated with the type. A tool can reflect on the
    type and use the presence of the
    <classname>ReferenceCountedAttribute</classname> attribute on a class to
    infer that it should be reference counted. .NET code can also query for
    this attribute on a class at runtime.</para>
    
    <para>Obviously, having tools be able to extract this information is nice 
    and all, but ultimately worthless unless the execution engine itself 
    detects the attribute and acts on it.</para>
    
    <sect2 id="chapter_4-sect.2.1"> 
      <title>The SSCLI class loader</title>
    
      <para>Loading a new type into the runtime is a quite involved process, and 
      involves building the <classname>EEClass</classname> and 
      <classname>MethodTable</classname> instances associated with the type 
      as described in the previous chapter.</para>
      
      <para>When a managed executable is run by the 
      <application>clix</application> executable launcher, the <application>
      sscoree</application> dynamic library is loaded and the 
      <function>_CorExeMain2</function> function is called. This function 
      initializes the runtime and eventually ends up calling the 
      <methodname>ClassLoader::ExecuteMainMethod</methodname> method. 
      <methodname>ExecuteMainMethod</methodname> figures out which type 
      contains the entry point for the assembly, loads it and then executes it.
      </para>
      
      <para>By the time it has gotten that far, though, the 
      <classname>ClassLoader</classname> has already loaded the classes that 
      are central to the execution engine, such as <classname>Object</classname>,
      <classname>Array</classname> and <classname>String</classname>. The 
      main work horse when it comes to loading classes is the 
      <methodname>ClassLoader::LoadTypeHandleFromToken</methodname> method. It
      takes in a <firstterm>metadata token</firstterm> for the requested type 
      (extracted from the assembly metadata) and builds an
      <classname>EEClass</classname> instance (and by extension, a
      <classname>MethodTable</classname> instance). The 
      <classname>EEClass</classname>/<classname>MethodTable</classname> pair
      is then used by the runtime to create instances of the type.</para>    
    </sect2>
    
    <sect2 id="chapter_4-sect.2.2">
      <title>Detecting reference counted types</title>
      <para>In order to determine whether a type is reference counted, I need
      to check whether the <classname>ReferenceCounted</classname> attribute is
      present on that type. </para>
      
      <sect3 id="chapter_4-sect.2.2.1">
        <title>The SSCLI metadata APIs</title>
        <para>The SSCLI provides an API that allows you to manipulate, emit and 
        inspect the metadata for an API. This API is public and intended for use
        by writers of compilers and other tools, but is also used extensively 
        internally in the execution engine.</para>
        
        <para>The metadata API is COM-based and the relevant interfaces can be 
        found in <filename>/clr/src/inc/cor.h</filename>. The interface used 
        for metadata inspection is <classname>IMetaDataImport</classname>.
        Internally in the runtime, the name <classname>IMDInternalImport
        </classname> is used. As far as I have been able to tell, this is the
        same interface, and I have been able to use the documentation for 
        <classname>IMetaDataImport</classname> in my work with 
        <classname>IMDInternalImport</classname>.
        </para>
      </sect3>
      
      <para>I implemented a global function <function>IsReferenceCounted()
      </function> that takes a metadata token for the type and determines 
      whether the <classname>ReferenceCountedAttribute</classname> attribute
      is applied to it. The implementation resides in 
      <filename>/clr/src/vm/nstruct.cpp</filename> and looks like this:</para>
      
      <example><programlisting><![CDATA[
HRESULT IsReferenceCounted(IMDInternalImport *pInternalImport, mdTypeDef cl )
{
    const void *pData;
    ULONG cbBlob;

    // we only need to know if there is such an attribute on the type
    HRESULT hr = pInternalImport->GetCustomAttributeByName( cl, 
        "System.ReferenceCountedAttribute", &pData, &cbBlob);

    return hr;
}
]]></programlisting></example>

    <para>The function returns <constant>S_OK</constant> if the attribute 
    exists and <constant>S_FALSE</constant> if it doesn't. Any other return
    value is treated as an error.</para>  
    
    <para><classname>EEClass</classname> contains a series of bitflags 
    describing various attributes of the type in question. I added a new flag
    indicating a reference counted class (in <filename>/clr/src/vm/class.cpp
    </filename>:</para>
<example><programlisting><![CDATA[
VMFLAG_ISSINGLEDELEGATE                = 0x10000000,
VMFLAG_ISMULTIDELEGATE                 = 0x20000000,
VMFLAG_PREFER_ALIGN8                   = 0x40000000, // Would like to have 8-byte alignment
VMFLAG_REFERENCECOUNTED                = 0x80000000,

// ...

inline BOOL EEClass::IsReferenceCounted()
{
    return (m_VMFlags & VMFLAG_REFERENCECOUNTED);
}

inline void EEClass::SetReferenceCounted()
{
    m_VMFlags |= VMFLAG_REFERENCECOUNTED;
}
]]>
</programlisting></example>
      <para>I also added similar flags and accessors on <classname>MethodTable
      </classname>. Obviously, this is a duplication of information since it 
      could also be accessed through the  
      <classname>MethodTable</classname>'s pointer to the 
      <classname>corresponding</classname> EEClass, but there is ample 
      precedent in the existing code for doing it this way. I can only assume
      the idea is to avoid accessing the <classname>EEClass</classname> at 
      runtime if possible, for performance reasons.</para> 
      
      <para>Now, the class loader merely has to call 
      <function>IsReferenceCounted</function> and set the flag accordingly in 
      <methodname>ClassLoader::LoadTypeHandleFromToken()</methodname>
      (<filename>/clr/src/vm/clsload.cpp</filename>):</para>  
<example><programlisting><![CDATA[
// is the type reference counted?    
hr = IsReferenceCounted(pInternalImport, cl);

BOOL fIsReferenceCounted = (hr == S_OK);
if(FAILED(hr) && hr != S_FALSE) 
{
    m_pAssembly->PostTypeLoadException(pInternalImport, cl, IDS_CLASSLOAD_BADFORMAT, pThrowable);
    return hr;
}

// ...

if (fIsReferenceCounted) 
    pClass->SetReferenceCounted();

]]></programlisting> </example>             
      
    </sect2>
  </sect1>
  
  <sect1>
    <title>The reference counted heap</title>
    <para>The reference counted objects cannot share the same heap as the
    garbage collected objects use. The objects on the garbage collected heap
    are routinely moved and/or discarded as part of a garbage collection sweep,
    a mechanism which doesn't take into account the needs of the reference 
    counted objects. </para> 
    
    <sidebar>
      <title>The large object heap</title>
      <para>Not all objects are placed on the garbage collected heap even in the
      existing SSCLI implementation. Large objects, in the SSCLI defined as
      objects bigger than 85,000 bytes, are allocated and managed on a separate
      heap. This heap, the large object heap, is further subdivided into two: a
      section for objects that contain internal pointers to other objects and 
      a section for those without such pointers. This is due to the large cost
      of scanning such large objects for pointers. The garbage collector
      queries the <classname>MethodTable</classname> instance for an object to
      determine whether it contains internal pointers.</para>
      
      <para>The cost of constantly moving objects as big as those on the large 
      object heap would be prohibitive, so the garbage collector does not use
      compaction for these objects. Instead they are managed by a more 
      traditional malloc-style heap.</para>    
    </sidebar>
    
    <para>It is then obvious that another heap implementation is necessary to
    fill the needs of the reference counting mechanism. I have decided here to
    reuse the malloc-style allocator used for the large object heap. While it
    may not be optimized for the needs of allocating a lot of small objects, it
    is well encapsulated from the rest of the implementation and can be swapped
    out for a more efficient implementation at a later time. Investigating such
    implementations might serve as a good topic for further work on this
    research. </para>
    
    <para>The implementation of the heap used for the LOH is located in 
    <filename>/clr/src/vm/gmheap.cpp</filename>. I created a class 
    <classname>ReferenceCountedHeap</classname> in 
    <filename>clr/src/vm/refcount.[cpp|h]</filename>, which encapsulates this 
    implementation and provides the operations necessary to support allocation
    and deallocation of reference counted objects: </para>
    
    <example><programlisting><![CDATA[
class ReferenceCountedHeap
{
public:
    ReferenceCountedHeap()
    {;}

    HRESULT Initialize();
    Object* Alloc(DWORD size);
    void Free(void* ptr);
private:
    gmallocHeap* m_Heap;
};  
    ]]></programlisting></example>
    
    <para><classname>gmallocHeap</classname> here is the malloc implementation.
    </para>
    
    
    <para>The runtime maintains a global instance of 
    <classname>ReferenceCountedHeap</classname>, accessed 
    through the pointer <varname>g_pRCHeap</varname> which is declared in 
    <filename>clr/src/vm/vars.hpp</filename>. This matches the way the runtime
    has a global variable for the garbage collected heap, 
    <varname>g_pGCHeap</varname>. An accessor function in 
    <filename>refcount.cpp</filename> is used to allocate objects from the 
    reference counted heap:</para>
    <example><programlisting><![CDATA[
OBJECTREF RCAllocateObject( MethodTable* pMT )
{
    // TODO: locking
    THROWSCOMPLUSEXCEPTION();

    // allocate memory for it
    Object* orObject = (Object*)g_pRCHeap->Alloc(pMT->GetBaseSize());

    // verify that the memory is zeroed out.
    _ASSERTE( ! orObject->HasSyncBlockIndex() );
    
    // make sure it has a method table
    orObject->SetMethodTable(pMT);

    RCLogAlloc(pMT, orObject);

    return( ObjectToOBJECTREF(orObject) );    
}    
    
    ]]></programlisting></example>
    
    <para>This global instance also needs to be initialized. I have created a function
    <function>InitializeReferenceCountedHeap()</function> which is called from
    <function>InitializeEE()</function>, the main initialization function of 
    the execution engine. The implementation merely creates an instance of 
    <classname>ReferenceCountedHeap</classname> and calls its 
    <methodname>Init() method.</methodname><footnote><para>I have, as much as 
    possible tried to use the same coding conventions as are used by the 
    existing code. Personally, I would rather have performed any initialization
    in the constructor, but I don't see it as my role to impose my personal 
    idioms on an existing codebase. When in Redmond, do as the Redmondians.
    </para></footnote>
    </para>    
  </sect1>
  
  <sect1>
    <title>Allocating reference counted objects</title>
    <para>The JIT compiler is a separate component that communicates with the 
    execution engine proper through the <classname>ICorJitInfo</classname> 
    interface (<filename>/clr/src/inc/corjit.h</filename>). This interface is 
    implemented by the <classname>CEEInfo</classname> class in 
    <filename>/clr/src/vm/jitinterface.cpp</filename>. Whenever the JIT
    compiler needs to emit a call to allocate an object, it calls 
    <methodname>CEEInfo::getNewHelper()</methodname>. This method investigates
    the <classname>MethodTable</classname> of the object that needs to be 
    allocated and returns a constant corresponding to an appropriate helper 
    function.</para>
    
    <para>I created a new constant, <constant>CORINFO_HELP_NEWREFCOUNTEDOBJECT
    </constant>and injected this code into <methodname>CEEInfo::getNewHelper():
    </methodname></para>
    
    <example><programlisting><![CDATA[
    
// ...

// is this a reference counted object?
if (pMT->IsReferenceCounted())
{
    return CORINFO_HELP_NEWREFCOUNTEDOBJECT;
}

// ... 
    ]]>
    </programlisting></example>
    
    <para><varname>pMT</varname> is here a pointer to the 
    <classname>MethodTable</classname> object for the class the runtime needs 
    to allocate an instance of. <methodname>IsReferenceCounted()</methodname>
    is the accessor method I created earlier.</para>
    
    <para>The JIT compiler then calls <methodname>CEEInfo::getHelperFtn()
    </methodname>which maps the constant to a function pointer through a table. 
    A call to this function is emitted into the generated native code.
    <constant>CORINFO_HELP_NEWREFCOUNTEDOBJECT</constant> maps to the function
    <function>JIT_NewRefCountedObject()</function>, which does some 
    housekeeping and then calls the <function>RCAllocateObject()</function>
    function described earlier.</para>
  </sect1>
  
  <sect1>
    <title>Keeping track of reference counts</title>
    <para>One important question remains unanswered at this point: Where do
    we store the reference count for an object? The first solution that comes to
    mind is to introduce a new field in the <classname>Object</classname> class.
    However, this would mean that <emphasis>all</emphasis> objects, reference
    counted or not, have to pay the cost of this extra field. Since the purpose
    of this whole exercise is to find a way for both reference counting and 
    mark and sweep garbage collection to coexist, this is clearly unacceptable.
    </para>
    
    <para>Another solution might be to create a subclass of 
    <classname>Object</classname>, <classname>ReferenceCountedObject</classname>,
    containing this field. XXX more here</para>
    
    <para>The solution I eventually landed on was to replicate the mechanism
    used to allocate and place the <classname>ObjHeader</classname>; i.e., placing 
    it <emphasis>before</emphasis>the actual <classname>Object</classname> 
    instance. Obviously, the <classname>ObjHeader</classname> is already located
    in front of <classname>Object</classname>, so I need to locate it before 
    that. This means that the actual runtime layout of a reference counted 
    object on the reference counted heap ends up looking like this:</para>
    
    <figure id="chapter_4-fig-1">
      <title>Runtime layout of reference counted types</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="refcountheader.png" format="png"/> 
        </imageobject> 
      </mediaobject>
    </figure>
    
    <sect2>
      <title><classname>ReferenceCountHeader</classname></title>
      
      <para>The reference count of a reference counted object is managed by 
      an instance of the class <classname>ReferenceCountHeader</classname>. It
      has a design that resembles that of COM's <classname>IUnknown:</classname>
      </para>
      
      <example><programlisting><![CDATA[
class ReferenceCountHeader
{
public:
    ReferenceCountHeader() : m_RefCount(0)
    {;}

    ULONG AddRef();
    ULONG Release();
    ULONG ReferenceCount()
    {
        return m_RefCount;
    }

    Object* GetObject();
private:
    void Finalize();
    int m_RefCount;
};
]]></programlisting></example>


      <para>The semantics of <methodname>AddRef()</methodname> and 
      <methodname>Release()</methodname> should be obvious in this context, 
      even to people without COM experience. The implementation of 
      <methodname>GetObject()</methodname> is worth taking a look at, though. 
      It uses some pointer arithmetic to retrieve the pointer to the actual 
      <classname>Object</classname> instance associated with this object:</para>
      
      <example><programlisting><![CDATA[
Object* ReferenceCountHeader::GetObject()
{
    return (Object*) ((ObjHeader*)(this + 1) + 1);
}  
      ]]></programlisting></example>
      
       <para>Obviously, the size of the <classname>ReferenceCountHeader
       </classname> also needs to be taken into account when allocating object 
       instances<footnote><para>The <parameter>size</parameter> parameter here 
       already incorporates the size of the <classname>ObjHeader</classname>
       instance.</para></footnote>:</para>
       
<example><programlisting><![CDATA[
Object* ReferenceCountedHeap::Alloc(DWORD size)
{
    // we need some space for our accounting needs too
    DWORD realSize = size + sizeof(ReferenceCountHeader);

    // get the space for it on the heap
    BYTE* newAlloc = (BYTE*)m_Heap->Alloc(realSize);
    memclr((BYTE*)newAlloc, realSize);

    // account for the space allocated for the ObjHeader and the 
    // ReferenceCountHeader
    return (Object*) (newAlloc + sizeof(ReferenceCountHeader) + sizeof(ObjHeader));
}
]]></programlisting></example>     
    </sect2>
    
    <sect2>
      <title><methodname>GC.ReferenceCount</methodname></title>
      <para>The <methodname>ReferenceCount()</methodname> accessor method in 
      <classname>ReferenceHeader</classname> was added to serve as the underlying
      foundation for a new method on the <classname>GC</classname> class, 
      <methodname>GC.ReferenceCount</methodname>. The <classname>GC</classname>
      class is part of the BCL and contains various methods to control the 
      garbage collector, such as explicitly starting a garbage collection sweep, 
      suppressing and reenabling finalization of objects and discovering which
      generation an object is currently part of.</para>
      
      <para>The <methodname>GC.ReferenceCount()</methodname> method allows 
      a .NET developer to query the runtime for the current reference count
      of a reference counted object. It is implemented as an internal call
      into the runtime:</para>
      <example><programlisting><![CDATA[
[MethodImplAttribute(MethodImplOptions.InternalCall)]
private static extern int nativeReferenceCount(Object o);

public static int ReferenceCount(Object o)
{
    if (o == null)
        throw new ArgumentNullException("o");
    return nativeReferenceCount(o);
}
      ]]></programlisting></example>
      
      <para>The <constant>MethodImplOptions.InternalCall</constant> argument
      to the <classname>MethodImplAttribute</classname> attribute here 
      indicates that the real implementation of the method can be found in 
      native code inside the execution engine. The runtime maps the call
      through a table into a method on the <classname>GCInterface</classname>
      class. This method merely calls the <methodname>ReferenceCount()</methodname> 
      method on the  <classname>ReferenceCountHeader</classname> associated
      with the object, after verifying that it actually is a reference counted
      object (<filename>clr/src/vm/comutilnative.cpp</filename>):</para>     
      <example><programlisting><![CDATA[
FCIMPL1(int, GCInterface::ReferenceCount, Object *obj)	
{	
 	  THROWSCOMPLUSEXCEPTION();	

 	  if (!obj->GetMethodTable()->IsReferenceCounted())	
 	      FCThrow(kInvalidOperationException);	

 	  return obj->GetReferenceCountHeader()->ReferenceCount();	
}      
      ]]></programlisting>
      </example>
      
    </sect2>
    
  </sect1>
  
  <sect1>
    <title>Modifying the JIT compiler</title>
    
    <para>There is now a mechanism in place to allocate and free reference 
    counted objects, as well as incrementing and decrementing their reference
    counts. The next step is to modify the JIT compiler in such a way that the 
    reference count for an object is implicitly managed. Unlike COM in C++, 
    the mechanism introduced here should not require the developer to manually
    call <methodname>AddRef()</methodname> or <methodname>Release()</methodname>.
    </para>
    
    <para>The intent is to make the use of reference counted objects as 
    transparent as possible, while still providing a very deterministic life 
    time and finalization for such objects. Take the following example:</para>
    
    <example><programlisting><![CDATA[

for( int i = 0; i < BigConstant; i++ )
{
  SomeType obj = new SomeType();
  obj.SomeOperation()
}   
    ]]></programlisting></example>
    
    <para>Here, a new instance of the <classname>SomeType</classname> 
    class is created for each iteration of the loop. In the traditional 
    CLR environment, the memory for the allocated objects would not be recycled
    and the memory use would continue to grow, possibly triggering a garbage
    collection. If the object also has non-trivial finalizer requirements, the
    memory use would be even worse, since the objects would not be cleaned up
    immediately in a garbage collection, instead having to wait for the 
    finalizer thread to deal with them.</para>
    
    <para>The goal of the implementation here is to ensure that in the example
    above, there will never be more than a single instance of 
    <classname>SomeType</classname> in existence at any given iteration of the 
    loop. If <classname>SomeType</classname> has a finalizer, it should be 
    executed synchronously at the end of the loop. This is as opposed to the
    asynchronous behavior of the current CLR finalization mechanism.</para>
    
    <para>The mechanism I have chosen is to have all reference counted objects
    be created with an initial reference count of 0. When they are assigned
    to a local variable, a parameter or a class field, their reference count 
    gets incremented by one. If the local variable, parameter or class field
    already holds a reference to a reference counted object, the reference 
    count of that object gets decremented by one. If they hold no reference, 
    they contain null.</para>
    
    <para>I proceeded to create two JIT helper functions, JIT_AddRef and JIT_Release 
    (<filename>/clr/src/vm/jitinterface.cpp</filename>):</para>
    
    <example><programlisting><![CDATA[
HCIMPL1(void, JIT_AddRef,  Object* obj)
{
    if (obj == NULL)
        return;

    HELPER_METHOD_FRAME_BEGIN_NOPOLL();

    _ASSERTE(obj->GetMethodTable()->IsReferenceCounted());

    obj->GetReferenceCountHeader()->AddRef();

    HELPER_METHOD_FRAME_END();
}
HCIMPLEND    
    
    ]]></programlisting></example>
    
    <para><function>JIT_Release</function> is similar.</para>
    
    <sect2>
      <title>The JIT compiler</title>
      <para>In the SSCLI, the JIT compiler is a separate component from the 
      execution engine proper. It resides in the directory 
      <filename>/clr/src/fjit</filename>. The F in fjit presumably stands for 
      <quote>fast</quote>, although the JIT in the SSCLI does not seem to be
      the same as that in the commercial .NET implementation, and is not very
      optimized. </para>
      
     <para>The implementation of the JIT compiler mostly consists of a large
      switch statement over the various IL opcodes. The switch calls various
      helper methods, which in turn emits the native code through several
      layers ofincreasingly processor-specific macros. The extensive use of the
      C++ macro mechanism here makes working with the code a lot harder than it
      should be, since the macros are not very friendly to debuggers and it is
      sometimes very hard to see what code is actually being executed. Working
      with this part of the code was one of the hardest parts of implementing
      reference counting, and it often took me days to figure out how to do 
      some of these things.</para>
    </sect2>
    
    <sect2>
      <title>Handling local variables</title>
      <para>In CIL, local variables are handled by the <function>ldloc
      </function> and <function>stloc</function> instructions. They load or store
      the value of a local variable from or to the IL execution stack. The IL
      execution stack does not actually exist in the emitted native code, but 
      the semantics of it are mostly emulated by the processor stack. For 
      example, a <function>ldloc</function> usually translates into 
      something like this:</para>
      
      <example><programlisting><![CDATA[
mov         eax,dword ptr [ebp-10h]
push        eax
      ]]></programlisting></example>
      
      <para>In other words, the local is retrieved from the stack frame and 
      pushed onto the stack. The JIT does not push the local onto the stack in 
      all cases, though. If it is to be reused instantly, for example in some
      calculation, it is merely kept in the CPU register. The JIT constantly
      keeps track of whether the <firstterm>Top Of Stack</firstterm> (TOS) is
      on the CPU stack or in a register. On the IA/32 architecture, the 
      register used for the TOS is always <varname>eax</varname>.</para>
      
      <para>Emitting code for the <function>stloc</function>
      instruction is handled by the
      <methodname>FJit::compileDO_STLOC</methodname> method. Here I call two
      helper methods which conditionally emits calls to <function>AddRef()
      </function> or <function>Release()</function> depending on 
      whether the local variable is a reference counted object or not:</para>
      
      <example><programlisting><![CDATA[
// make sure to call .Release() on the old object in the var
maybeReleaseArgOrVar(varInfo);    

trackedType = varInfo->type;
//trackedType.toNormalizedType();
TYPE_SWITCH_PRECISE(trackedType,emit_STVAR, (varInfo->offset));

// emit a call to increase the reference count if the new object is reference counted
maybeAddRefArgOrVar(varInfo);      
      
      ]]></programlisting></example>
      
      <para><methodname>maybeAddRefArgOrVar() looks like this:</methodname></para>
      
      <example><programlisting><![CDATA[
FJitResult FJit::maybeAddRefArgOrVar(stackItems* varInfo) {
    if (isRefCounted(varInfo->type))
    {                               
        callInfo.reset();
        TYPE_SWITCH_PRECISE(varInfo->type, emit_LDVAR, (varInfo->offset));
        emit_tos_arg( 1, INTERNAL_CALL );
        emit_callhelper_I4(jitInfo->getHelperFtn(CORINFO_HELP_ADDREF));
    }

    return FJIT_OK;
}      
      ]]></programlisting></example>
      
      <para>Here I actually emulate the semantics of the <function>ldloc
      </function> instruction to load the value of the variable so it can
      be passed on the CPU stack for the call to the helper function.</para>
      
      <para><methodname>isRefCounted</methodname> is a helper function which 
      calls into the execution engine to determine whether the local is a 
      reference counted object. Doing this at JIT time instead of at runtime
      has some interesting implications, a topic which I will revisit later.</para>
      
      <para>XXX: more here</para>
      
   </sect2>
   
   <sect2>
      <title>Parameters</title>      
      
      <para>Parameters are just another type of local variables, and the 
      <function>starg</function> instruction to store a value in a parameter is 
      handled in an almost identical way (thus the name 
      <methodname>maybeAddRefArgOrVar()</methodname>) to <function>stloc</function>. 
      The method handling the emitting of native code in this case is
      <methodname>FJit::compileDO_STARG</methodname>.</para>
      
      <para>However, parameters also have another aspect when it comes to 
      reference counting: when an object is passed as a parameter to another
      method, it needs to have its reference count incremented. Further, this
      reference count needs to be decremented at the end of the method.</para>
      
      <para>JIT-compiling a single method is handled by the 
      <methodname>FJit::compileMethod</methodname> method. At the beginning I
      insert a call to this emitParameterAddRefCalls():</para>
      
      <example><programlisting><![CDATA[
FJitResult FJit::emitParameterAddRefCalls() {
    int paramCount = methodInfo->args.numArgs;
    stackItems* paramInfo;

    for(int i = 0; i < paramCount; i++ )
    {
        paramInfo = &argsMap[i];
        OpType type = paramInfo->type;

        // is this a reference counted type?
        if (type.isRef() && jitInfo->isReferenceCounted(type.cls()))
        {
            callInfo.reset();
            TYPE_SWITCH_PRECISE(type, emit_LDVAR, (paramInfo->offset));
            emit_tos_arg( 1, INTERNAL_CALL );
            emit_callhelper_I4(jitInfo->getHelperFtn(CORINFO_HELP_ADDREF));
        }
    }

    return FJIT_OK;
}      
      ]]></programlisting></example>
      
      <para>Here, a call to <function>AddRef()</function> is emitted for every
      reference counted parameter passed to the JIT-compiled method.</para>
      
      <para>A similar function called at the end of 
      <methodname>FJit::compileMethod</methodname> emits calls to 
      <function>Release()</function> on every parameter <emphasis>and</emphasis> local 
      variable. This, in addition to the way objects have their reference count
      decremented every time a local is overwritten with a new value, ensures 
      that objects are deallocated and finalized as soon as they go out of 
      scope. As mentioned earlier, objects referenced by local variables have 
      their reference counts incremented to 1 when they are initially assigned.</para>
    </sect2>  
    
    <sect2>
      <title>Class fields</title>
      <sect3>
      <title>Assignments</title>
      <para>While dealing with local method/function variables and parameters
      was a pretty straightforward task, assignments to class fields also
      needed to be intercepted and dealt with. Unfortunately, this did not turn
      out to be quite as simple as the work on locals. The code in the JIT
      compiler dealing with this was rather complex, and the way the JIT
      compiler is implemented, with numerous layers of increasingly
      CPU-specific C++ macros, tended to obfuscate matters a great deal.</para>
      
      <para>I spent a lot of time trying to decipher exactly what the JIT
      macros were doing in order to inject code to call
      <function>AddRef()</function> and <function>Release()</function> whenever 
      class fields are assigned to. In addition to trying to understand the
      macros, another source of difficulty lay in the implicit dependencies 
      between the way the various IL instructions were handled by the JIT. 
       </para>
       
      <para>The instruction for field assignment in CIL is 
        <function>stfld</function>. The semantics of <function>stfld</function>
        are as follows (with regard to the IL execution stack, which must not
        be confused with the native CPU stack):</para>
       
       <orderedlist>
        <listitem><para>An object reference is pushed onto the stack (this
        step is skipped for assignments to static fields).</para>
        </listitem>
        
        <listitem><para>The value that is to be assigned to the field is pushed
        onto the stack.</para></listitem>
        
        <listitem><para><function>stfld</function> <parameter>field</parameter> 
        is executed. <parameter>field</parameter> here is a metadata token for
        the field that is to be assigned to.</para></listitem>        
       </orderedlist>
       
       <para>For assigning a value to a non-static field of an object, the 
       following IL is generated by the C# compiler:</para>
       
       <example>
        <title>Simple field assignment in IL</title>
        <programlisting><![CDATA[
ldloc.0       // load a local variable onto the stack
ldc.i4.s  42  // load the value '42' onto the stack  
stfld int32::TestField::Field // store the top-of-stack into this field
        ]]></programlisting>        
       </example>
       
       <para>This parallells what the code emitted by the JIT compiler does with 
       regards to the native CPU stack. <footnote><para>I have, in my work on 
       the JIT compiler, exclusively focused on supporting the IA/32 
       architecture. Since the JIT compiler is fairly well abstracted from the
       actual CPU architecture through its layers of macros, my changes should
       also work on PowerPC CPUs, but I have not tested this configuration.
       </para></footnote>. On the IA/32 architecture, the JIT compiler emits 
       something like this for the above IL:</para> 
       
       <example>
        <title>Emitted x86 code for field assignment:</title>
        <programlisting><![CDATA[
06FE0039  mov         eax,dword ptr [ebp-10h] 
06FE003C  push        eax  
06FE003D  mov         eax,2Ah 
06FE0042  push        eax  
06FE0043  mov         eax,4 
06FE0048  push        eax  
06FE0049  mov         eax,6D819C4h 
06FE004E  call        eax  
06FE0050  add         esp,0Ch 
        
        ]]></programlisting>
      </example>
      
      <para>This assembler code pushes the address of the object and the value
        to be assigned to the field onto the CPU stack, followed by the offset
        into the object where the field is located. A helper function which 
        performs the actual field assignment is then called.</para>
      
      <para>The problem is that, by the time the JIT compiler encounters the
        <function>stfld</function> instruction, all the code up to where the field 
        offset is pushed has already been emitted by the handlers for the other
        IL instructions. However, I also need access to the values that are on 
        the stack in order to do several things:
      </para>
      
      <orderedlist>
        <listitem><para>I need to call <methodname>Release()</methodname>
          on the value previously stored in the field, if it is a reference
          to a reference counted object.</para></listitem>
          
        <listitem><para>The original semantics of the <function>stfld
          </function> instruction needs to be preserved.</para></listitem>
        
        <listitem><para>I need to call <methodname>AddRef()</methodname></para>
          on the new object reference stored in the field.</listitem>        
      </orderedlist>
      
      <para>The first part is simple; I can emit code to do the equivalent of
      the <function>ldfld</function> instruction to get at the previous object
      reference in the field. That will leave the address of this object on the
      top of the native stack, and I can emit a call to
      <function>Release()</function>. However, this needs to be followed by a
      call to the original helper function for <function>stfld</function>, and
      that leaves me with a problem: The stack frame is no longer set up for
      this call. And I have yet another function call to emit after that!</para>
      
      <para>The approach I eventually landed on was this: I first pop off all
      the arguments that have previously been put on the stack when reaching
      the <function>stfld</function> instruction. I then set up stack frames
      for an <function>ldfld</function>, <function>stfld</function> followed
      by yet another <function>ldfld</function>. The two 
      <function>ldfld</function>s are used to get at the object stored in the
      field in order to call <function>Release()</function> and 
      <function>AddRef()</function> on it. All this is handled by the 
      <methodname>FJit::doEmitSTFLD_REF</methodname> helper method:</para>
      
      <example>
        <title>FJitResult FJit::doEmitSTFLD_REF</title>
        <programlisting><![CDATA[        
pop_register(CALLEE_SAVED_1, 0); // offset	
pop_register(ARG_1, 0); // RHS object	
pop_register(CALLEE_SAVED_2, 0); // LHS object	

// push for the second LDFLD call	
push_register(CALLEE_SAVED_2, 0); // object	
push_register(CALLEE_SAVED_1, 0); // offset	

// push for the STFLD call	
push_register(CALLEE_SAVED_2, 0); // LHS object	
push_register(ARG_1, 0); // RHS object	
push_register(CALLEE_SAVED_1, 0); // offset	

// push for the first LDFLD call	
push_register(CALLEE_SAVED_2, 0); // object	
push_register(CALLEE_SAVED_1, 0); // offset	

// get the object stored in the slot	
emit_LDFLD_REF(isStatic);	

// call Release() on it	
callInfo.reset();	
emit_tos_arg(1, INTERNAL_CALL);	
emit_callhelper_I4(jitInfo->getHelperFtn(CORINFO_HELP_RELEASE));	

// now the actual STFLD	
emit_STFLD_REF((isStatic));	

// get the new object in that slot	
emit_LDFLD_REF(isStatic);	

// AddRef() it	
callInfo.reset();	
emit_tos_arg(1, INTERNAL_CALL);	
emit_callhelper_I4(jitInfo->getHelperFtn(CORINFO_HELP_ADDREF));
 	         ]]></programlisting>
      </example>
      
      <para>The above code is simplified and only applies to non-static fields;
      the stack frames are slightly different for static fields. The actual 
      code takes this into account and deals with static field assignments 
      properly.</para>
      
      </sect3>
      
      <sect3>
        <title>Releasing class fields</title>
        
        <para>When an object of a reference counted type is destroyed, it 
        should call <methodname>Release()</methodname> on all of its reference
        counted fields (if it has any). It would also be beneficial if this
        behavior could be achieved for objects of <quote>normal</quote> types;
        types tracked by the tracing garbage collector.</para>
        
        <para>Achieving the former should be relatively simple; just go through
        the values of any reference counted fields at the time of destruction 
        and call <function>Release()</function> on them directly. Doing the 
        latter requires some more thought. The main problem is that the garbage
        collector really isn't - it does not <emphasis>collect</emphasis> 
        garbage as much as it collects non-garbage and dumps the rest. This 
        unfortunately (for me) means that objects that are garbage are not 
        visited by the collector before they are disposed of, leaving no way
        to decrement the reference counts on any fields held by the object.        
        </para>
        
        <para>The approach I have chosen is to treat objects with reference 
        counted fields as if they have a finalizer. The objects will then be
        placed on the finalizer queue which gives us a way to to intercept them
        and deal with them before they are disposed of. When the finalizer is 
        eventually called, it will iterate over all the reference counted fields 
        and decrement their reference counts one by one. This solution has the 
        added benefit of being usable for both types of objects; for objects
        controlled by the tracing GC the finalizer is called by the finalizer 
        thread, and for reference counted objects the finalizer is called by 
        the implementation of <methodname>Release()</methodname>.</para>
        
        <sect4>
          <title>Discovering reference counted fields</title>
          <para>In order to mark objects of types that have reference counted
          fields as finalizable, it is necessary to discover exactly which 
          types of objects this condition applies to. The natural place for 
          performing such discovery is in the class loading mechanism.</para>
          
          <para>In the CLR, the binary layout of a type isn't decided by the 
          front end compiler. This is in contrast to how traditional language
          compilers work, where the binary layout of everything is hardcoded
          into the resulting executable. Instead, the CLR lays out fields at runtime
          when a type is initially loaded. This gives the execution engine a 
          large amount of flexibility to choose a layout that is optimal for 
          the environment in which the program is to run.<footnote><para>This 
          obviously does not apply to structs that have explicit layout 
          information associated with them. In the CLR, explicit layout of 
          struct fields can be achieved using the 
          <classname>StructLayout</classname> attribute.</para></footnote>
          </para>
          
          <para>Laying out fields is handled by the 
          <methodname>EEClass::InitializeFieldDescs()</methodname> method. I 
          initially assumed it would just be a matter of checking the types of
          the fields and querying their <classname>EEClass</classname> instance 
          as to whether they are reference counted or not. Alas, it turned out
          not to be that simple. At the time a type is loaded, you have no 
          guarantee that the types of all of its fields are loaded as well. This
          makes sense, since loading the types of all fields would cause a 
          cascade of type loads. Instead, the 
          class loading mechanism does without exact type information, relying 
          only on information about field sizes to determine a type's binary
           layout.</para>
           
           <para>Fortunately, it <emphasis>is</emphasis> possible to extract
           a metadata token for the type of a field from the metadata token
           for the field itself. Given a metadata token for the type, I can use
           the same approach as I take to initially discover reference counted 
           types. To extract this information from the field one needs to query
           its <firstterm>signature</firstterm>. In the CLR, a signature is a
           packed structure of binary data, which needs to be parsed in order 
           to obtain the desired information. The SSCLI provides the 
           <classname>SigPointer</classname> class to parse a signature. Given
           a field signature that represents a reference to an object, the 
           metadata token for the object type is the third item. When the 
           metadata token has been acquired, I can merely delegate to the 
           <function>IsReferenceCounted()</function> function I wrote earlier 
           that determines whether the <classname>ReferenceCounted</classname>
           attribute is applied to it.</para>
           
           <example>
            <title>The <function>IsRCField()</function> function</title>
            <programlisting><![CDATA[
HRESULT IsRCField(IMDInternalImport* pInternalImport, mdFieldDef fd)	
{	
 	ULONG size;	
 	PCCOR_SIGNATURE sig = pInternalImport->GetSigOfFieldDef(fd, &size);	

 	SigPointer sigptr(sig);	

 	// the first part of the sig defines the calling convention	
 	_ASSERTE(sigptr.GetData() == IMAGE_CEE_CS_CALLCONV_FIELD);	

 	// then comes the type	
 	CorElementType corType = (CorElementType)sigptr.GetData();	

 	// we only deal with class objects	
 	if (corType == ELEMENT_TYPE_CLASS)	
 	{	
 	    // next part of the signature is the metadata token for the field	
 	    mdTypeDef type = sigptr.GetToken();	
 	    return IsReferenceCounted(pInternalImport, type);	
 	}	
 	else	
 	    return S_FALSE;	
}           
            ]]></programlisting>
           </example>
           
           <para>This function, <function>IsRCField()</function>, is called 
           <methodname>InitializeFieldDescs()</methodname> for each field in 
           a type. When a reference counted field is found, a flag is set in 
           the <classname>EEClass</classname> and the 
           <classname>MethodTable</classname> that indicates that the type has
           one or more reference counted fields. This flag is then checked by
           the tracing garbage collector when objects of the type are allocated
           in order to determine if the new object should be placed on the
           finalizer queue. If the flag is set, it gets placed on the 
           queue regardless of whether it has other finalizer requirements. It
           is then up to the <methodname>MethodTable::CallFinalizer()</methodname>
           method to determine whether an object needs to perform traditional
           finalizer tasks, decrement reference counts on fields or both.
           </para>
           
           <para>For a reference counted type, 
           <methodname>CallFinalizer()</methodname> calls the 
           <methodname> MethodTable::FinalizeRefCountedFields()</methodname>
           helper method. This method iterates over all the fields of the object
           and calls <methodname>Release()</methodname> on any non-null reference
           counted object:</para>
           
           <example>
            <title><methodname>MethodTable::FinalizeRefCountedFields</methodname></title>
            <programlisting><![CDATA[
while ((curField = fdIterator.Next()) != NULL)	
{	
  // get the class for this type and check if it has RC fields	
 	EEClass* fieldType = curField->FindType().AsClass();	
 	if (fieldType->IsReferenceCounted())	
 	{	
 	    OBJECTREF fieldObj = NULL;	
 	    curField->GetInstanceField(obj, (LPVOID)&fieldObj);	

 	    // release this object	
 	    if (fieldObj != NULL)	
 	    {	
 	        fieldObj->GetReferenceCountHeader()->Release();	
 	    }	
 	}	
}            
            ]]></programlisting>
           </example>
        </sect4>
      </sect3>
      
    </sect2>   
    
  </sect1>
  
</chapter>

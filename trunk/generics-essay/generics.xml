<?xml version="1.0" encoding="utf-8" ?>
<!--<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN" 
    "file:///t:/docbook-dtd/docbookx.dtd">-->
<!--  
    vim:et ts=4 tw=78
-->
<article>
    <artheader>
        <title>Generics in C#</title>
        <author>
            <firstname>Arild</firstname>
            <surname>Fines</surname>
        </author>
    </artheader>
    <abstract>
        <para>
            This essay will discuss a new mechanism that will be introduced in
            version 2.0 of the <firstterm>Common Language
            Runtime</firstterm> (CLR), known as <firstterm>generics</firstterm>.
            We will take a look at how generics will be used when programming in
            various programming languages targeting the CLR, with an emphasis
            on the <firstterm>C# programming language</firstterm>. We will
            review how the CLR implements generics, and compare the
            implementation of generics in .NET with the way the Java Virtual 
            Machine performs the same task.
        </para>
    </abstract>
    <sect1>
        <title>What is the Common Language Runtime?</title>
        <para>The Common Language Runtime (CLR) is the central component of
        Microsoft's new development initiative <firstterm>.NET</firstterm>. It
        encompasses a runtime environment with rich support for a variety of
        modern object-oriented programming languages, allowing them to
        interoperate on a binary level. Components written in one language can
        be consumed directly by components written in another language as long
        as they both target the CLR.</para>

        <para>Accompanying the first release of .NET was a new programming
        language, C#, which takes full advantage of the features available in
        the CLR.</para>
        
        <para>The .NET initiative in general was intended to replace Microsoft's
        component technology known as COM/DCOM as the premier choice for
        enterprise development on the Microsoft Windows platform, and has been
        marketed aggressively to compete against Sun Microsystem's Java
        programming language and the J2EE architecture.</para>

        <para>Microsoft's flagship development environment <firstterm>Visual
        Studio</firstterm> has a broad range of support for programming against
        the CLR. The current version of Visual Studio, Visual Studio 2003, lets
        developers target the CLR using 4 different languages: C++, Visual
        Basic, C# and Visual J#. It also allows third party compiler writers to
        integrate their compilers into the environment through the<link
        linkend="vsip"> <firstterm>Visual Studio Industry Partner
        Program</firstterm></link>.</para>

        <para>The CLI has been standardized through the <firstterm>European Computer
        Manufacturers Association</firstterm> (ECMA) and the <firstterm>International
        Standards Organization</firstterm> (ISO) under the designations <link
        linkend="ecma335">ECMA-335</link> and
        <link linkend="iso23271">ISO/IEC 23271</link>, respectively.</para>
        
        <sect2>
        <title>The CLR's type system</title>
       <para> The CLR's type system reflects the fact that it is targetted
        primarily (but not exclusively) towards object-oriented languages. It
        supports two main categories of types:</para>
        <variablelist>
            <varlistentry><term>objects</term>
                <listitem>Object types are always allocated on the heap. Any
                representation of an object as a local variable merely consists
                of a pointer to the object.</listitem>
            </varlistentry>
            <varlistentry><term>value types</term>
                <listitem>value types are essentially nothing more than a
                sequence of bytes, and are represented as such on a program's
                stack. They are allocated either on the runtime
                stack or inline in objects that contain them. They support
                methods, but not inheritance, although they can implement one or
                more interfaces. All primitive types, such as integers and
                floats, are represented in the CLR type system as value
                types</listitem>
            </varlistentry>
        </variablelist>

        <para>The inherent impedance between these two categories is one of the things
        that make a mechanism like generics desirable.</para>

        <para>The CLR also has support for a wide variety of other useful types,
        such as pointers, arrays and <firstterm>delegates</firstterm> (type safe
        function pointers), but they are implemented in terms of one of the
        above types.</para>
        
        <para>In the CLR, the <type>Object</type> type serves as the root of its
        single inheritance hierarchy. Objects are not allowed to have more
        than one superclass, but they can implement any number of
        interfaces.</para>
        
        <!-- structs/valuetypes vs heap objects -->
        <!-- delegates -->

            <sect3>
            <title>The Common Type System(CTS)</title>
            <para>The <firstterm>Common Type System</firstterm> is a specification
            which represents the minimum of types a language targetting the CLR
            should be able to consume and produce. It is a subset of the full
            type system. Partition II of the <link linkend="ecma335">ECMA
            standard</link> describes the CTS.</para>

            </sect3>
        </sect2>
        
        <sect2> <title>Common Intermediate Language(CIL)</title>
        <para>The <firstterm>Common Intermediate Language</firstterm>(CIL) is
        the language output by a compiler targetting the CLR. The language
        consists of a series of instructions manipulating a virtual stack based
        machine. However, this stack machine is intended to be purely
        hypothetical - CIL is designed to be compiled to native machine code
        before it is executed. This in contrast to the bytecodes of the JVM,
        which were originally designed to be executed directly by such a stack
        machine, implemented on top of the real hardware.</para>

        <para>CIL is described in Partition III of the <link
        linkend="ecma335">ECMA standard</link> </para>
        
        <para>The term MSIL(Microsoft
        Intermediate Language) describes Microsoft's implementation of CIL. This
        abbreviation is often (incorrectly) used interchangeably with CIL and/or
        IL.</para> 
        </sect2>
        
    </sect1>
    <sect1>
        <title>What are generics?</title>
        <para>Wikipedia <link linkend="wikipgen">defines</link> generics as
        <quote>a technique that allows one value to take different datatypes
        (so-called polymorphism) as long as certain contracts such as subtypes
        and signature are kept.</quote> It further defines <firstterm>generic
        programming</firstterm> as <quote>the programming style emphasizing use
        of this technique.</quote></para>
        
        <para>This is a rather abstract definition, but the concept of generics 
        eventually boils down to the ability to parameterize a custom datatype
        on one or more types. The canonical example of a parameterized type is
        a collection class that can be parameterized on the types it holds. For
        example, a <type>List</type> class can be configured to hold either 
        integers or<type>Foo</type> objects, but not at the same time. With
        .NET generics in C#, the use of such a class would look like this:</para>
        <programlisting>
        <![CDATA[        
List<Foo> list = new List<Foo>();
list.Add( new Foo(42) );
list.Add( new Foo(84) );

Foo foo = list[0]; // get the first item in the list
        ]]>        
        </programlisting>
        <para>Since this list is parameterized on the <type>Foo</type>, any
        attempt to insert objects of another type would generate a compile-time
        error:</para>
        <programlisting>
        <![CDATA[
        
list.Add( 42 ); // ERROR: int is not a Foo
list.Add( new Bar() ); // ERROR: Bar is not a Foo

        ]]>        
        
        </programlisting>
        
        <para>Of course, normal polymorphic substitutability rules apply. If,
        in the above example, <type>Bar</type> was a class deriving from
        <type>Foo</type>, the insertion would be allowed by the compiler.</para>
        
        <sect2>
           <title>What exactly is <quote>polymorphism</quote>, and what does it
            have to do with generics?</title> 
            
            <para>The term polymorphism
            derives from the Greek words <quote>poly</quote>, meaning
            <quote>many</quote>, and <quote>morphos</quote>, meaning <quote>
            shape.</quote><footnote><para>Similarly, the word
            <quote>politics</quote> derives from <quote>poly</quote>, meaning 
            <quote>many</quote> and the word <quote>ticks</quote>, meaning
            <quote>nasty little bugs.</quote>.</para> </footnote> 
            
            In other words, it describes an entity that can take
            on many shapes. The most common application of the term in computer
            science is to describe the way most object oriented programming
            languages dispatch method calls on a type. However, it applies
            equally well to <quote>function overloading</quote>(several
            functions having the same name, but different argument lists) and
            <quote>generics</quote>. In generics, the generic type takes on a
            different 'shape' for each different type it is parameterized on.
            </para>
        </sect2>
        
        <!-- C# programmers coming from C++ - miss templates -->
        <!-- define "polymorphism" -->
        <!-- parametric polymorphism vs dynamic/virtual approaches 
        advantages of pp -->
        <!-- other languages supporting 'generics'(in a broad sense) -->

        <sect2>
        <title>The motivation for generics in .NET</title>
        In versions of the CLR prior to (the not yet released)2.0, developers
        have had certain options when it came to storing their custom types in 
        containers:
        <variablelist>
            <varlistentry>
                <term>Use the standard object-based containers.</term>
                <listitem><para>The .NET Framework Base Class Library(BCL)
                ships with an adequate set of container classes, all storing
                items of type <type>Object</type>. Using these containers for
                value types had certain performance implications since it
                incurred the cost of <firstterm>boxing</firstterm>. It also
                relinquished compile-time type safety, since the compiler had
                no way of checking that only objects of one type were inserted
                into the container. Additionally, retrieving objects from the
                container required a cast operation. This cast was not entirely
                free, since the compiler had to insert code to do a runtime
                type check and potentially cast an exception if the real object
                type didn't match the type cast to.</para></listitem>
            </varlistentry>
            
            <varlistentry>
                <term>Write custom containers from scratch.</term>
                <listitem><para>You could, of course, always write your
                IntegerList class from scratch. This would avoid the boxing
                problem associated with the use of the standard containers and
                value types(described above), and there would be no need for a
                cast when retrieving an object from the list.</para>
                
                <para>The obvious downside is of course that writing such
                custom containers is extremely dull gruntwork that incurs
                development and maintenance costs. Additionally, you would
                rarely need only a single specialized container, leading to the
                explosion of <type>IntegerList</type>, <type>FloatList</type>
                and <type>FooList</type> objects all over the place. If you
                wanted to change the algorithm used or the interface of these
                classes, you needed to ensure that the changes were made in all
                of them.</para>
                </listitem>                
            </varlistentry>
            <varlistentry>
                <term>Use a code generator.</term>
                <listitem><para>Of course, since writing a custom container
                from scratch is <quote>extremely dull gruntwork</quote>, it is
                a perfect candidate for automation by a computer. There are
                several tools out there that take as input the types the
                container should store, and spits out a perfect custom
                container that requires no casting or boxing, even for primitives.
                </para></listitem>
            </varlistentry>
        </variablelist>
        <!-- use explicit interface implementation, derive from CollectionBase, use ArrayList-->
        <!-- boxing, unboxing -->
        <!-- code generation -->
        <!-- examples -->
        </sect2>
        <sect2>
            <title>Uhh... what's this <quote>boxing</quote> thing?</title>
            <para>Essentially, boxing is a mechanism that allows you to store
            value types on the heap as a regular object. As the reader may
            remember, value types as local variables or member variables are
            stored merely as the sequence of bytes which they represent,
            instead of as a pointer to a heap object as with reference types.</para>
            
            <para>In order to store a value type in a container class that holds
            only <type>Object</type>s, you therefore need to copy it to a heap
            object so you can pass that heap object's reference to the container's
            <function>Add()</function> method.</para>
            
            <para>When the value type is retrieved from the container, the reverse
            operation, called <firstterm>unboxing</firstterm>, is needed. This 
            extracts the bytes for the value type and recreates it on the stack
            as a local variable.</para>
            
            <para>While boxing and unboxing are conceptually very elegant ways
            of solving the heap object/value type impedance problem, there is 
            little question that there is a performance cost inherent in it.
            </para>
        </sect2>
       
    </sect1>
    <sect1>
        <title>.NET generics</title>
        <para>A preliminary specification for version 2.0 of the C# programming
        language was released in October 2003. It contained, as everyone had
        expected, a proposal for a generics mechanism, in addition to other new
        features as <firstterm>anonymous methods</firstterm>,
        <firstterm>iterators</firstterm> and <firstterm>partial types.</firstterm>
        While the other three features are exciting in their own right, they will 
        not be discussed any further here.
        </para>
        
        <para>Comments made by Microsoft employees involved with the language
        design on C# and .NET newsgroups and blogs indicated that generics
        was a feature they had wished to include in the very first release of C#,
        but that time did not permit it. Taking the time to do it properly is 
        understandable, considering what a mess templates in C++ have turned out to 
        be. <footnote><para><quote>C++: An octopus made by nailing extra legs
        onto a dog.</quote></para></footnote>.</para>
        
        <para>The C#/.NET implementation of generics is based on work done
        by Don Syme and Andrew Kennedy at Microsoft Research in the UK.
        They released a prototype of their implementation codenamed
        <firstterm>Gyro</firstterm> as a set of files to be extracted over the
        source to to Microsoft's <firstterm><link linkend="rotor">Shared Source</link> 
        </firstterm> version of the .NET Framework. <link linkend="pldi2001"> 
        Their work</link> was presented at 2001's Programming Language Design
        and Implementation (PLDI) convention. </para>
        
        <sect2>
            <title>Generics in action.</title>
            
            <para>In mid-2004, Microsoft shipped the first beta of .NET 2.0, 
            ïncluding generics support for both VB.NET and C#, as well as 
            additional classes in the BCL taking advantage of this support.</para>
            
            <para>More specifically, it shipped with a new namespace: 
            <type>System.Collections.Generic</type> In this namespace, classes
            and interfaces taking advantage of the generics functionality to 
            provide typesafe containers can be found. Here's an example of
            how one could use <type>Dictionary&lt;V, K&gt;</type>:</para>
            <programlisting>
        <![CDATA[   
Dictionary<string, int> myMap = new Dictionary<int>();
myMap["answer"] = 42;
myMap["airspeed velocity of an unladen European Swallow"] = 10;
]]></programlisting>     
            <para>What we are witnessing here is the
            <emphasis>instantiation</emphasis> of a generic type. A
            <type>Dictionary&lt;V, K&gt;</type> cannot be used directly - type
            parameters have to be specified for K and V.</para> 
        
            <para>In this case, there is no boxing involved even though a 
            value type (int) is stored in the collection. Also, since the types
            involved are known at compile time, there is no need for a runtime
            type check such as that involved in a cast. The instantiation
            of the dictionary is specialized for the types used, just as if 
            you (or a code generator) had written it yourself. This lack of
            boxing when storing value types is what differentiates the Java
            implementation of generics from the .NET one, as we shall see 
            later on.</para>  
            
            <para>Further, here is an example of an implementation of a 
            linked list using generics (this example is <link linkend="linklistexample">
            taken from the .NET 2.0 documentation</link>):</para>
            <programlisting>
        <![CDATA[
  
using System;
using System.Collections.Generic;

public class MyList<T>//type parameter T in angle brackets
{
        private Node head;
        // The nested type is also generic on T.
        private class Node          
        {
            private Node next;
            //T as private member data type:
            private T data;          
            //T used in non-generic constructor:
            public Node(T t)         
            {
                next = null;
                data = t;
            }
            public Node Next
            {
                get { return next; }
                set { next = value; }
            }
            //T as return type of property:
            public T Data            
            {
                get { return data; }
                set { data = value; }
            }
        }
        public MyList()
        {
            head = null;
        }
        //T as method parameter type:
        public void AddHead(T t)     
        {
            Node n = new Node(t);
            n.Next = head;
            head = n;
        }

        public IEnumerator<T> GetEnumerator()
        {
            Node current = head;

            while (current != null)
            {
                yield return current.Data;
                current = current.Next;
            }
        }
    }
]]></programlisting>
            <para>When you instantiate a <type>List&lt;T&gt;</type>, the T will
            be substituted with the type you provide for T.</para>
            
            <para>Although we won't explore it further, it is worth mentioning
            that the <function>GetEnumerator()</function> method with its
            <function>yield</function> keyword is an example of one of the other
            three prominent new features of C# 2.0: Iterators.</para>   
        </sect2>   
        
        <sect2>
            <title>Application of generics</title>
            <para>Generics are not restricted to being used on classes. You can
            also have generic methods, generic interfaces and generic delegates.
            The BCL provides several generic delegates, of which this one is a 
            good example:</para>
<programlisting>
public sealed delegate bool Predicate&lt;T&gt;(
    T obj
);
</programlisting>
            <para>Combined with anonymous methods, you can use the above delegate
            type like this:</para><programlisting>
            <![CDATA[

int[] arr = new int[100];

// fill the array with integers

int[] evenNumbers = Array.FindAll<int>( arr, delegate(val)
{
    return (val % 2) == 0;
});
]]>         
            </programlisting>
            
            <para>In this case, the second parameter to <function>FindAll</function>
            is a <function>Predicate&lt;T&gt;</function>.</para>
                        
        </sect2>
            
                        

        <!-- examples -->
        <!-- type inference -->
        <!-- type constraints -->
        <!-- restrictions - Type variables cannot be used to specify a base
        class. No con -->
        <!-- Generics in the BCL -->
        <!-- Reflecting on generic instantiations -->

        <sect2>
            <title>Performance of generics</title>
            <para>
                Since casts and boxing has been eliminated, generic types
                will outperform their non-generic counterparts by a 
                significant factor. The following (rather unscientific) benchmark
                gives a perspective on the differences:                
            </para>
<programlisting>
<![CDATA[
#region Using directives

using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;

#endregion

namespace ConsoleApplication5
{
    class Program
    {
        static void Main( string[] args )
        {
            Random rand = new Random();
            ArrayList arrayList = new ArrayList( 1000000 );

            int ticks = Environment.TickCount;
            for ( int i = 0; i < arrayList.Capacity; i++ )
                arrayList.Add( rand.Next() );

            arrayList.Sort();
            Console.WriteLine( "ArrayList: {0}", Environment.TickCount - ticks );

            ticks = Environment.TickCount;
            List<int> genericList = new List<int>( 1000000 );
            for ( int i = 0; i < genericList.Capacity; i++ )
                genericList.Add( rand.Next() );
            genericList.Sort();
            Console.WriteLine( "List<int>: {0}", Environment.TickCount - ticks );

        }
    }
}
]]>
</programlisting>
        </sect2>
        <para>On the author's machine, the above gives the following output:</para>
            <screen>
<![CDATA[
T:\ConsoleApplication5\ConsoleApplication5\bin\Release>ConsoleApplication5.exe 
ArrayList: 5207                                                                
List<int>: 1402   
]]>                                                                   
        </screen>
        <para>Although this test is rather contrived, it gives a good rough image
        of the performance differences involved when choosing a generic
        approach over an object-based one.</para>       
    </sect1>
    <sect1>
        <title>The implementation.</title>        
        <para>In .NET, the generics design pervades the entire runtime and the
        .NET type system. This in contrast to, as we shall investigate later,
        the approach taken by the implementation of generics in the JVM. The
        .NET runtime natively understands generic types and knows that they are
        different from non-generic types.</para>

        <para>To show that the CLR natively understands generics, let's take a
        look at an example:</para>
        <programlisting>
<![CDATA[

using System;

namespace Test
{
    class Generic<T>
    {
        public Generic( T t )
        {
            this.t = t;
        }

        public string Value()
        {
            return this.t.ToString();
        }
        private T t;
    }

    class NonGeneric
    {
        public NonGeneric( object o )
        {
            this.o = o;
        }

        public string Value()
        {
            return this.o.ToString();
        }

        private object o;
    }
    class Test
    {
        public static void Main()
        {
            string s = "42";
            Generic<string> g = new Generic<string>( s );
            string res = g.Value();
            Console.WriteLine( res );

            Generic<object> g2 = new Generic<object>( s );
            res = g2.Value();
            Console.WriteLine( res );

            NonGeneric ng = new NonGeneric( s );
            res = ng.Value();
            Console.WriteLine( res );
        }
    }
}

]]>
        </programlisting>
        <para>Now let's look at the CIL generated from the generic class
        definition:</para>
        <programlisting>
<![CDATA[


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi beforefieldinit Test.'Generic`1'<([mscorlib]System.Object) T>
       extends [mscorlib]System.Object
{
  .field private !T t
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!T t) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ldarg.0
    IL_0008:  ldarg.1
    IL_0009:  stfld      !0 class Test.'Generic`1'<!T>::t
    IL_000e:  nop
    IL_000f:  ret
  } // end of method 'Generic`1'::.ctor

  .method public hidebysig instance string 
          Value() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  1
    .locals init (string V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldflda     !0 class Test.'Generic`1'<!T>::t
    IL_0006:  constrained. !T
    IL_000c:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0011:  stloc.0
    IL_0012:  br.s       IL_0014

    IL_0014:  ldloc.0
    IL_0015:  ret
  } // end of method 'Generic`1'::Value

} // end of class Test.'Generic`1'

]]>
        </programlisting>
        <para>The `1 syntax means that we are dealing with a generic
        type. Additionally, the <function>constrained.</function> instruction
        is specific to generic types.</para> 
        
        <para>Let's compare with the code emitted for a non-generic
        type:</para>
        
        <programlisting>
        <![CDATA[
.class private auto ansi beforefieldinit Test.NonGeneric
       extends [mscorlib]System.Object
{
  .field private object o
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(object o) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ldarg.0
    IL_0008:  ldarg.1
    IL_0009:  stfld      object Test.NonGeneric::o
    IL_000e:  nop
    IL_000f:  ret
  } // end of method NonGeneric::.ctor

  .method public hidebysig instance string 
          Value() cil managed
  {
    // Code size       16 (0x10)
    .maxstack  1
    .locals init (string V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      object Test.NonGeneric::o
    IL_0006:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_000b:  stloc.0
    IL_000c:  br.s       IL_000e

    IL_000e:  ldloc.0
    IL_000f:  ret
  } // end of method NonGeneric::Value

} // end of class Test.NonGeneric
]]>
    </programlisting>
    <para>Here, for a non-generic class,  there is no use of the `1 construct.</para>

    <para>Unfortunately, the current beta release of the Microsoft 2.0
    Framework does not contain a specification for the instructions and the
    associated syntax used to implement generics in CIL. This will probably be
    fixed in future releases. At the very least, documentation will be
    provided when the generics mechanism has been included in the ECMA and ISO
    standards.</para>

    <sect2>
        <title>Instantiating a generic type</title> <para>Instantiation of
        generic types happen at runtime. When the Just In Time (JIT) compiler
        encounters a generic type, it will create native code for that
        instantiation. Of course, if there is a previous instantiation of that
        particular generic type for that specific set of type parameters, the
        implementation will be reused.</para>
    </sect2>
    <sect2>
        <title>Code sharing</title>

        <para>Additionally, if the native code emitted for a previous
        instantiation of a type is considered <quote>compatible</quote> with
        another type, this instantiation can be reused as well. All
        instantiations of a generic type parameterized on a class type (not a
        value type) can share the same native code. For example, the
        instantiations of <function>List&lt;string&gt;</function> and
        <function>List&lt;Button&gt;</function> will typically be identical,
        since neither <type>string</type> nor <type>Button</type> are value
        types, and the lists merely have to store references to the objects. A
        reference is typically represented as a native pointer type in machine
        code (Occupying 4 bytes on a 32 bit architecture like the x86). </para>

        <para>Instantiations for value types cannot so easily be shared, since
        value types typically have different sizes. For example, for a
        <type>List&lt;int&gt;</type>, the list contains items that each occupy 4
        bytes. For a <type>List&lt;double&gt;</type>, however, each item occupies 8
        bytes. This means that the binary layout of the list and its
        implementation will differ.  Although it is conceivable that an advanced
        JIT could do some degree of code sharing also in this case, this is not
        currently implemented.</para>

    </sect2>        
    </sect1>
    
    <sect1>
        <title>.NET generics versus Java generics</title>
        <para>When Sun Microsystems released Java 2, Standard Edition 5.0
        earlier this year, generics support was one of the big advancements
        over earlier versions. With this release, they beat .NET by having a
        working, non-beta, implementation of generics out on the market. The 
        .NET release featuring generics is still in beta.</para>

        <para>The Java implementation of generics was based on a research
        project named <link linkend="pizzacompiler">Pizza</link>, which was
        later turned into a Java Specification Request (JSR).</para>

        <para>While the syntax of generics in Java looks pretty similar to
        that of C#, the underlying implementation is vastly different. Let us
        look at an example:</para>
        <programlisting>
        <![CDATA[

public class List<T>
{
    public void add( T t )
    {
        // ...
    }

    public T getAt( int i )
    {
        // ...
    }

    // ...

    private T[] list;
}

public class Test
{
    public static void main( String[] args )
    {
        List<String> stringList = new List<String>();
        stringList.add( "The answer is " );
        stringList.add( "42" );

        String s = stringList.getAt( 1 );
        System.out.println( s );
    }
}
]]>
        </programlisting>
        <para>Except for the camelCase vs PascalCase issues, this syntax is
        pretty much identical to that of C#. However, what happens under the
        hood when the code is compiled is different.</para>

        <para>If the C# compiler had encountered the above example, it would
        have emitted CIL that indicated that the <type>List</type> class was
        a generic type, and it would have inserted CIL in the
        <function>main()</function> to instantiate a specialization of the
        List parameterized on the <type>String</type> class. The Java compiler
        does no such thing.</para>

        <para>In Java, the runtime (the JVM) does not have a concept of generic
        types at all. The JVM bytecode instruction set has not been modified
        to accommodate generics. The compiler is therefore limited to emitting
        the same bytecode as for a non-generic class. It has been speculated
        that this approach was chosen so that generic classes would run on
        downlevel JVMs (pre 5.0), but it has later turned out that this isn't
        true. A compiled generic class file will not run on downlevel JVMs.</para>

        <para>When the Java compiler encounters a generic class, it performs
        an operation on the generic class called <firstterm>type
        erasure</firstterm>. Type erasure basically means that the compiler
        strips out all the parametric types and replaces them with
        <type>Object</type>. The compiler would turn the above example into
        this:</para>
        <programlisting>
        <![CDATA[

public class List
{
    public void add( Object t )
    {
        // ...
    }

    public Object getAt( int i )
    {
        // ...
    }

    // ...

    private Object[] list;
}

public class Test
{
    public static void main( String[] args )
    {
        List stringList = new List();
        stringList.add( "The answer is " );
        stringList.add( "42" );

        String s = (String)stringList.getAt( 1 );
        System.out.println( s );
    }
}
]]>
        </programlisting>
        <para>Here, all parametric type information has been stripped out and
        the result resembles the implementation of a <type>List</type> class
        prior to the introduction of generics. It is worth noting that the
        compiler actually inserts casts for invocations of the
        <function>getAt</function> method. After performing the type erasure,
        the class is compiled just like a regular non-generic class, and the
        bytecode emitted bears no mark of being the end result from a generic
        type.</para>

        <sect2>
        <title>Implications of the Java approach</title>
            <para>The Java approach has some advantages: It is rather simple
            to implement, and it requires no changes to the JVM or the Java
            bytecodes. However, these advantages are far outweighed by the
            disadvantages. As one can see, when using generics in Java, the
            runtime casts are merely hidden, and you lose the performance
            benefit gained by using generics in .NET. If you parameterize a
            generic Java type on a value type, the Java compiler will actually
            <emphasis>insert</emphasis> the same kind of boxing and unboxing
            operations that are some of the motivation for introducing
            generics in .NET. The end result is that a Java generic container
            class gives you no performance benefit over an equivalent
            <type>Object</type>-based container.</para>

            <para>Another consequence of the Java implementation is that no
            information about the genericity of a class is available at
            runtime. Any attempt to perform reflection against our
            <type>List</type> class will reveal nothing more than that it's a
            class of type <type>List</type>. There is no way to retrieve
            information about which type it was parameterized on, or that it
            is in fact a generic type. All that information has been thrown
            away by the compiler. The .NET implementation, on the other hand,
            supports full reflection of generic types at runtime. The central
            class in .NET reflection, the <type>Type</type> class, contains a
            wide range of methods and properties that allow you to retrieve
            information about a generic type and the types it has been
            parameterized on.</para>
        
        </sect2>
    </sect1>
    <bibliography>
        <biblioentry id="pldi2001" xreflabel="pldi2001">
            <authorgroup>
                <author>
                    <firstname>Don</firstname>
                    <surname>Sym</surname>
                </author>
                <author>
                    <firstname>Andrew</firstname>
                    <surname>Kennedy</surname>
                </author>
            </authorgroup>
            <title>The Design and Implementation of Generics for the .NET Common Language Runtime</title>
            <pubdate>May 02, 2001</pubdate>
        </biblioentry>

        <biblioentry id="csgenericsintro" xreflabel="csgenericsintro">
            <authorgroup>
                <author>
                    <firstname>Juval</firstname>
                    <surname>Lowry</surname>
                </author>
            </authorgroup>
            <title>
                <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnvs05/html/csharp_generics.asp">
                An Introduction to C# Generics</ulink></title>
            <pubdate>August 2003</pubdate>
        </biblioentry>
         <biblioentry id="vsip" xreflabel="vsip">
            <title>
                Visual Studio Industry Partner Program
                <ulink url="www.vsipdev.com">
                www.vsipdev.com</ulink></title>
            <pubdate>August 2003</pubdate>
        </biblioentry>
        <biblioentry id="ecma335" xreflabel="ECMA335">
            <title>
                <ulink url="http://www.ecma-international.org/publications/standards/Ecma-335.htm">
                     http://www.ecma-international.org/publications/standards/Ecma-335.htm</ulink>
            </title>
        </biblioentry>
        <biblioentry id="iso23271" xreflabel="ISO23271">
            <title>
                <ulink url="http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36769">
                     http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36769</ulink>
            </title>
        </biblioentry>
        
         <biblioentry id="wikipgen" xreflabel="wikipgen">
            <title>
                <ulink url="http://en.wikipedia.org/wiki/Generic_programming">
                     http://en.wikipedia.org/wiki/Generic_programming</ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="rotor" xreflabel="Rotor">
            <title> 
                <ulink url="http://sscli.net">
                    Microsoft Shared Source CLI
                </ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="csspec" xreflabel="CSSPEC">
            <title>
                <ulink url="http://download.microsoft.com/download/8/1/6/81682478-4018-48fe-9e5e-f87a44af3db9/SpecificationVer2.doc">'
                    C# 2.0 Specification
                </ulink>
            </title>
        </biblioentry>
        
        <biblioentry id="linklistexample" xreflabel="LINKLISTEXAMPLE">
            <title>
                <ulink url="http://msdn2.microsoft.com/library/0x6a29h6.aspx">'
                    Generic linked list example
                </ulink>
            </title>
        </biblioentry>

        <biblioentry id="pizzacompiler" xreflabel="PIZZACOMPILER">
            <title>
                <ulink
                url="http://pizzacompiler.sourceforge.net/">http://pizzacompiler.sourceforge.net/</ulink>
            </title>
        </biblioentry>
    </bibliography>
</article>

